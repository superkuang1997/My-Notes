

# MySQL🐬

## 参考文档

👉  [MySQL 官方文档](https://dev.mysql.com/doc/refman/8.0/en/)

👉  [MySQL 5.1 中文文档](https://www.mysqlzh.com/)



# 逻辑架构🐬

## 连接管理与安全性



## 优化与执行



# 数据类型🐬

## 整型

`TINYINT `、`SMALLINT`、`MEDIUMINT`、`INT`、`BIGINT` 分别使用 8、16、24、32、64 位存储空间，一般情况下越小的列越好。



## 浮点数

`FLOAT` 和 `DOUBLE` 为浮点类型，`DECIMAL` 为高精度小数类型。cpu 原生支持浮点运算，但是不支持 `DECIMAl` 类型的计算，因此 `DECIMAL` 的计算比浮点类型需要更高的代价。

`FLOAT`、`DOUBLE` 和 `DECIMAL` 都可以指定列宽，例如 `DECIMAL(18, 9)` 表示总共18位，取 9 位存储小数部分，剩下 9 位存储整数部分。



## 字符串

主要有 `CHAR` 和 `VARCHAR` 两种类型，一种是定长的，一种是变长的。

`VARCHAR` 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 `UPDATE` 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。

在进行存储和检索时，会保留 `VARCHAR` 末尾的空格，而会删除 `CHAR` 末尾的空格。



## 时间和日期

MySQL 提供了两种相似的日期时间类型：`DATETIME` 和 `TIMESTAMP`。

- `DATETIME`

  能够保存从 1000 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间，它与时区无关。

  默认情况下，MySQ L以一种可排序的、无歧义的格式显示 `DATETIME` 值，例如 "2008-01-16 22<span>:</span>37<span>:</span>08"，这是 ANSI 标准定义的日期和时间表示方法。

- `TIMESTAMP`

  和 UNIX 时间戳相同，保存从 1970年1月1日 以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年。

  它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。

  MySQL提供了 `FROM_UNIXTIME()` 函数把 UNIX 时间戳转换为日期，并提供了 `UNIX_TIMESTAMP()` 函数把日期转换为 UNIX 时间戳，默认情况下，如果插入时没有指定 `TIMESTAMP` 列的值，会将这个值设置为当前时间。

  应该尽量使用 `TIMESTAMP`，因为它比 `DATETIME` 空间效率更高。



# 存储引擎🐬

MySQL 中的数据用各种不同的技术存储在文件或内存中，这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。



## InnoDB

InnoDB是默认的数据库存储引擎，他的主要特点有：

- 可以通过自动增长列，方法是auto_increment。

- 支持事务。默认的事务隔离级别为可重复度，通过 MVCC（并发版本控制）来实现的。

- 使用的锁粒度为行级锁，可以支持更高的并发；

- 支持外键约束；外键约束其实降低了表的查询速度，但是增加了表之间的耦合度。

- 配合一些热备工具可以支持在线热备份；

- 在 InnoDB 中存在着缓冲管理，通过缓冲池，将索引和数据全部缓存起来，加快查询的速度；

对于 InnoDB 来说，最大的特点在于支持事务。但是这是以损失效率来换取的



### 存储结构

1. `.frm` 文件：与表相关的元数据信息都存放在 frm 文件，包括表结构的定义信息等
2. `.ibd` 文件或 `.ibdata` 文件：这两种文件都是存放 InnoDB 数据的文件，之所以有两种文件形式存放 InnoDB的数据，是因为 InnoDB 的数据存储方式能够通过配置来决定是使用共享表空间存放存储数据，还是用独享表空间存放存储数据。



## MyISAM

MyIASM 是 MySQL 默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当 INSERT 或 UPDATE 数据时即写操作需要锁定整个表，效率便会低一些。

MyISAM 执行读取操作的速度很快，而且不占用大量的内存和存储资源。在设计之初就预想数据组织成有固定长度的记录，按顺序存储，MyISAM 是一种静态索引结构。



### 存储结构

1. `.frm`文件：与表相关的元数据信息都存放在 frm 文件，包括表结构的定义信息等
2. `.MYD` (`MYData`) 文件：MyISAM 存储引擎专用，用于存储 MyISAM 表的数据
3. `.MYI` (`MYIndex`)文件：MyISAM 存储引擎专用，用于存储 MyISAM 表的索引相关信息



## 两者的比较

|                        | MyISAM                                 | Innodb                                                       |
| ---------------------- | -------------------------------------- | ------------------------------------------------------------ |
| 事务                   | 支持事务                               | 不支持事务                                                   |
| 索引                   | 非聚簇索引                             | 聚簇索引                                                     |
| 并发                   | 只支持表级锁，操作一条记录即锁住整张表 | 支持行级锁                                                   |
| 外键                   | 不支持外键                             | 支持外键                                                     |
| 备份                   | 不支持在线热备份                       | 支持在线热备份                                               |
| 崩溃恢复               | 崩溃后发生损坏的概率比 InnoDB 高很多   | 崩溃后可以恢复                                               |
| 执行 `select count(*)` | 快，内部维护了一个计数器存储数据量     | 慢，不存储数据量（因为通过mvcc支持行锁，返回的数量条目是不确定的），需要全表扫描 |









# 索引🐬

索引是帮助 MySQL 高效获取数据的排好序的数据结构。

索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。

对于少量的数据，没有合适的索引影响不是很大，但是，随着数据量的增加，没有索引时读数据的性能会急剧下降。而当处理的数据达到百万级或千万级时，在查询和插入的时候耗时太长、性能低下，如果将表中的数据存储到不同的分区中，将大大提高数据的能力。

- 唯一索引

  非唯一索引是由关键字KEY或INDEX定义的索引，它唯一任务是加快对数据的访问速度。

  因此，应该只为那些最经常出现在查询条件或排序条件的数据列创建索引，例如年龄等。

- 非唯一索引

  允许被索引的数据列包含重复的值，如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字 UNIQUE 把它定义为一个唯一索引。

  唯一索引可以简化MySQL对这个索引的管理工作，索引也因此而变得更有效率，同时在有新记录插入数据表时，自动检查新记录的这个字段的值是否已经在某个记录的这个字段里出现过，如果是，MySQL将拒绝插入那条新记录，也就是说，唯一索引可以保证数据记录的唯一性。



## 索引的特点

优点：

- 大大减少了服务器需要扫描的数据行数。

- 帮助服务器避免进行排序和分组，以及避免创建临时表

  B+Tree索引是有序的，可以用于 `ORDER BY` 和 `GROUP BY` 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表。

- 将随机 I/O 变为顺序 I/O

  B+Tree索引是有序的，会将相邻的数据都存储在一起。

使用条件：

- 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；
- 对于中到大型的表，索引就非常有效；
- 但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。



## 索引的类型

### B+Tree索引

B+Tree 是大多数 MySQL 存储引擎的默认索引类型。

因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。

因为 B+Tree 的有序性，所以除了用于查找，还可以用于排序和分组，可以指定多个列作为索引列，多个索引列共同组成键。

适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。

InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。

> InnoDB中没有非聚簇索引

<img src="http://store.secretcamp.cn/uPic/image-20210310112332239202103101123321615346612ekxKxTekxKxT.png" alt="image-20210310112332239" style="zoom:50%;" />

辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。

<img src="http://store.secretcamp.cn/uPic/image-20210310112609968202103101126101615346770AoOy4oAoOy4o.png" alt="image-20210310112609968" style="zoom:50%;" />



### 哈希索引

哈希索引能以 $O(1)$ 时间进行查找，但是失去了有序性：

- 无法用于排序与分组；
- 只支持精确查找，无法用于部分查找和范围查找。

InnoDB 存储引擎有一个特殊的功能叫 "自适应哈希索引" ，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。



### 全文索引

MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。

查找条件使用 MATCH AGAINST，而不是普通的 WHERE。

全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。

InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。



## B+Tree索引的加载过程

如下是一个 B+Tree 索引，假设要查找数据项 6 ，那么过程如下：

1. 把根节点由磁盘块 0 加载到内存，发生一次 I/O，在内存中用二分查找确定 6 在 3 和 9 之间；
2. 通过指针 P2 的磁盘地址，将磁盘 2 加载到内存，发生第二次 I/O，再在内存中进行二分查找找到6，结束。

这里只进行了两次 I/O，实际上，每个磁盘块大小为 4kb，三层的 B+Tree 可以表示上百万的数据，也就是每次查找只需要 3 次I/O ，所以索引对性能的提高将是巨大的。

<img src="http://store.secretcamp.cn/uPic/image-20210602223050625202106022230501622644250zOJkaxzOJkax.png" alt="image-20210602223050625" style="zoom: 40%;" />





## 聚簇与非聚簇索引

数据库表的索引从数据存储方式上可以分为聚簇索引和非聚簇索引。

在 Innodb 中主键的索引被称为聚簇索引，其他列的索引被称为辅助索引

在 MyISAM 中主键的索引被称为非聚簇索引，其他列的索引被称为辅助索引

这两种不同引擎中的辅助索引存储的结构并不相同。

- 在 Innodb 中，辅助索引叶子节点存储的是对应主键的值，通过这个值再进行一次聚簇索引的查询
- 在 MyISAM 中，辅助索引叶子节点存储的对应数据行的地址，通过这个地址可以直接找到数据，需要注意的是，MyISAM 中的非聚簇索引和辅助索引功能是完全一样的，区别仅仅只是一个作用在主键列，一个作用在其他列上。



### 聚簇索引

 Innodb 使用聚簇索引（Clustered Index），"聚簇" 的意思是数据行被按照一定顺序一个个紧密地排列在一起存储。

如果表中定义了一个主键，InnoDB 将使用主键作为聚簇索引，如果没有定义，将选择第一个可以唯一标识的列作为聚簇索引列，如果也不存在这种列，InnoDB 会选择内置 6 字节长的 row_id 作为隐含的聚集索引。



#### 索引结构

InnoDB的数据文件本身（.ibd）就是索引文件，表数据文件本身就是按 B+Tree 组织的一个索引结构。

聚簇索引的顺序就是数据的物理存储顺序，它会根据聚集索引键的顺序来存储表中的数据，即对表的数据按索引键的顺序进行排序，然后重新存储到磁盘上。因为数据在物理存放时只能有一种排列方式，所以一个表只能有一个聚集索引，一旦创建了聚簇索引，表中的所有列都根据构造聚簇索引的关键列来存储。

Innodb 的聚簇索引在同一个 B+Tree 中保存了索引列和具体的数据，key 为主键（一般是），实际的数据 data 保存在叶子页（Leaf Page）中，叶子页就是 B+Tree 的叶节点所在的页。中间的节点页保存指向下一层页面的指针。

<img src="http://store.secretcamp.cn/uPic/image-20210602224438497202106022244381622645078XM3OkHXM3OkH.png" alt="image-20210602224438497" style="zoom:50%;" />

<img src="http://store.secretcamp.cn/uPic/image-20210602224555602202106022245551622645155IDaVNRIDaVNR.png" alt="image-20210602224555602" style="zoom:50%;" />



聚簇索引性能最好而且具有唯一性，所以非常珍贵，必须慎重设置，一般默认是主键，选取的原则一般要根据这个表最常用的SQL 查询方式来进行选择，如果已经设置了主键为聚簇索引，必须先删除主键，然后添加想要的聚簇索引，最后设置成主键即可。





#### 页分裂

页（Page）可以理解为一块具有一定大小的连续的存储区域。相同页内的数据行在物理上是相邻的，因此逻辑上键值相邻的页在物理上可能相隔很远。因此，B+Tree 相邻页中的数据，在物理上相距很远。

如果聚簇索引的列是无序的值例如 uuid ，那么向 B+Tree 中插入新节点会频繁的造成页分裂，即重新组织树的数据结构。

频繁的页分裂，页会变得稀疏并不被规则填充，数据会有碎片。

<img src="http://store.secretcamp.cn/uPic/image-20210603002336253202106030023361622651016wcwuOqwcwuOq.png" alt="image-20210603002336253" style="zoom:50%;" />



建议使用自增列作为主键，主键的值是顺序的，所以 InnoDB 把每一条记录都存储在上一条记录的后面。当达到页的最大填充因子时（InnoDB 默认的最大填充因子是页大小的 15/16，留出部分空间用于以后修改），下一条记录就会写入新的页中。一旦数据按照这种顺序的方式加载，主键页就会近似于被顺序的记录填满。

<img src="http://store.secretcamp.cn/uPic/image-20210603002602680202106030026021622651162OtYiyVOtYiyV.png" alt="image-20210603002602680" style="zoom:50%;" />



#### 回表查询

- 若对主键进行查询，例如 `WHERE id = 11` ，按照 B+Tree 的检索算法即可查找到对应的叶节点，之后获得行数据。
- 若对其他列进行查询，比如 `WHERE name = "Ellison"` ，则需要借助辅助索引：
  - 第一步：在辅助索引 B+Tree 中检索 name ，到达其叶子节点获取对应的主键。
  - 第二步：使用主键在主索引 B+Tree 中再执行一次检索操作，最终到达叶子节点即可获取整行数据。

<img src="http://store.secretcamp.cn/uPic/image-20210310150004300202103101500041615359604yUlZnHyUlZnH.png" alt="image-20210310150004300" style="zoom: 50%;" />



有一种情况通过辅助索引查询但不需要回表，那就是查询的列是辅助索引中记录的，即索引包含所有需要查询的字段的值，这种情况被称为 "覆盖索引"。

```sql
# id 、name 都可以从辅助索引中获得
SELECT id, name FROM table WHERE name = "Ellison";
```

但是如果查询的列还有辅助索引无法直接提供的，那就必须要借助聚簇索引进行回表查询。

```sql
# score 无法从辅助索引中获得
SELECT id, name, score FROM table WHERE name = "Ellison";
```



#### 优缺点分析

优点：

- 数据访问更快，因为索引和数据保存在同一个树中

- 根据局部性原理，聚簇索引的数据组织形式更易于访问相关数据。由于行数据和叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，已经把整页数据加载到了内存中，再次查询的时候，可以在内存中直接访问，不必访问磁盘。
- 聚簇索引对于范围查询的效率很高，因为其数据是按照大小排列的



缺点：

- 聚簇数据最大限度地提高了 I/O 密集型应用的性能，如果数据全部在内存，那么聚簇索引就没有什么优势

- 聚簇索引的插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式

- 聚簇索引的更新代价比较高，聚簇索引在插入新行和更新主键时，可能导致 "页分裂"，需要将数据移动到相应的位置。
- 聚簇索引可能导致全表扫描速度变慢，因为 B+Tree 中数据存储比较稀疏，需要加载物理上相隔较远的页到内存中。



注意事项：

1. 为什么不宜使用过长的字段作为主键？

   因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。
   
   


2. 为什么不宜使用 uuid 之类的字段作为主键？

   InnoDB 数据文件本身是一颗 B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持 B+Tree 的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。

   uuid 不具有有序性，所以在写的时候要对节点进行插入操作，需要读取整个 B+Tree 节点到内存，写的过程中会造成页分裂，插入节点后会将整个节点写回磁盘，这种操作在记录占用空间比较大的情况下，性能下降明显。另外，由于频繁页分裂造成 B+Tree 中页变得稀疏并不被规则填充，索引查询时会按页记载，因此  I/O 的次数也会增多。

   

3. 自增主键在什么场景下会产生不好的结果？

   - 单主数据库架构，那么自增 id 是不会重复，但在高并发场景下，按主键顺序插入可能造成明显的争用，这里会成为系统的瓶颈，而且也容易成为一个单点故障。

   - 主从架构，可以解决单点故障的问题，但不会解决生成 id 瓶颈的问题。在主数据库挂掉，进行主从切换的时候，这个自增 id 可能出现重复。

     可以使用 snowflake 算法，但缺点是生成 id 生成依赖系统时钟，如果时钟回调会出现 id 重复。



### 非聚簇索引

MyISAM 使用非聚簇索引（Non- Clustered Index），其索引结构的叶子节点指向了数据对应行的物理地址。



#### 索引结构

MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。

在 MyISAM 的索引中，主键索引 B+Tree 的节点存储了主键，辅助键索引 B+Tree 中存储了辅助键。主索引和辅助索引在结构上没有任何区别，只是主索引要求 key 是唯一的，而辅助索引的 key 可以重复。

<img src="http://store.secretcamp.cn/uPic/image-20210602223941285202106022239411622644781jeMPxsjeMPxs.png" alt="image-20210602223941285" style="zoom: 40%;" />

<img src="http://store.secretcamp.cn/uPic/image-20210602224141379202106022241411622644901njNaCrnjNaCr.png" alt="image-20210602224141379" style="zoom:40%;" />



这两个 B+Tree 的叶子节点都使用一个地址指向真正的表数据，由于索引树是独立的，通过辅助键检索也无需访问主键的索引树。





### 两者的比较

- 无论是聚簇索引还是非聚簇索引，在主 B+Tree 中节点发生变化，也就是发生了行移动时，辅助索引都不会受到影响。
- 聚簇索引适合用在排序的场合，非聚簇索引不适合
- 聚簇索引适合查询一定范围数据，可以将相关数据保存在一起。
- 聚簇索引维护索引的代价很昂贵，特别是插入新行或者主键被更新导致要分页时。
- 聚簇索引可能导致全表扫描速度变慢，因为可能需要加载物理上相隔较远的页到内存中（需要耗时的磁盘寻道操作）。



| **动作**           | **使用聚簇索引** | **使用非聚簇索引** |
| ------------------ | ---------------- | ------------------ |
| 列经常被分组排序   | 应该             | 应该               |
| 返回某范围内的数据 | 应该             | 不应该             |
| 一个或极少不同值   | 不应该           | 不应该             |
| 小数目的不同值     | 应该             | 不应该             |
| 大数目的不同值     | 不应该           | 应该               |
| 频繁更新的列       | 不应该           | 应该               |
| 外键列             | 应该             | 应该               |
| 主键列             | 应该             | 应该               |
| 频繁修改索引列     | 不应该           | 应该               |



## 建立索引的原则

- 选择唯一性索引

  唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录

- 为经常需要排序、分组和联合操作的字段建立索引

- 限制索引的数目

  越多的索引，会使更新表变得很浪费时间

- 尽量不使用无序的字段作为索引

  例如 uuid 不具有有序性，会导致 B+ 树索引在写的时候有过多的随机写操作（连续的 ID 可以产生部分顺序写），还有，由于在写的时候不能产生有顺序的 append 操作，而需要进行 insert 操作，将会读取整个 B+ 树节点到内存，在插入这条记录后会将整个节点写回磁盘，这种操作在记录占用空间比较大的情况下，性能下降明显。





## 最左前缀匹配

最左前缀匹配原则：以最左边的为起点任何连续的索引都能匹配上，遇到范围查询（>、<、between、like）就会停止匹配。

最左前缀原则主要使用在联合索引中，假如创建一个 (a,b) 的联合索引，那么它的索引树如下所示：

<img src="http://store.secretcamp.cn/uPic/image-20210327092123599202103270921231616808083BnJ52VBnJ52V.png" alt="image-20210327092123599" style="zoom: 33%;" />



可以看到 a 的值是有顺序的，1，1，2，2，3，3，而 b 的值是没有顺序的 1，2，1，4，1，2。所以 `b = 2` 这种查询条件没有办法利用索引，因为联合索引首先是按a排序的，b是无序的。

同时也可以观察到，在 a 值相等的情况下，b 值又是按顺序排列的，但是这种顺序是相对的。所以 `a = 1 and b = 2` 这样的查询条件可以用到索引，但是最左匹配原则遇上范围查询就会停止，剩下的字段都无法使用索引，例如 而 `a > 1 and b = 2` 中只有 a 字段可以用到索引，b 不可以，因为 a 是一个范围，在这个范围内 b 是无序的。



假如建立一个联合索引 (a,b,c)

1. 全值匹配查询时

   ```sql
   select * from table_name where a = '1' and b = '2' and c = '3' 
   select * from table_name where b = '2' and a = '1' and c = '3' 
   select * from table_name where c = '3' and b = '2' and a = '1' 
   ```

   都可以用到索引，WHERE 的搜索条件顺序调换不影响查询结果，因为 MySQL 中有查询优化器，会自动优化查询顺序 



2. 匹配左边的列时

   ```java
   select * from table_name where a = '1' 
   select * from table_name where a = '1' and b = '2'  
   select * from table_name where a = '1' and b = '2' and c = '3'
   ```

   都从最左边开始连续匹配，用到了索引

   ```sql
   select * from table_name where  b = '2' 
   select * from table_name where  c = '3'
   select * from table_name where  b = '1' and c = '3'
   ```

   没有从最左边开始，最后查询没有用到索引，用的是全表扫描 
   
   ```sql
   select * from table_name where a = '1' and c = '3' 
   ```
   
   只用到了 a 列的索引，没有用到 b 和 c 的索引



3. 匹配列前缀

   如果列是字符型的话它的比较规则是先比较字符串的第一个字符，第一个字符小的哪个字符串就比较小，如果两个字符串第一个字符相同，那就再比较第二个字符，第二个字符比较小的那个字符串就比较小，依次类推，比较字符串。

   如果 a 是字符类型，那么前缀匹配用的是索引，后缀和中缀只能全表扫描了

   ```sql
   select * from table_name where a like 'As%';   //前缀都是排好序的，走索引查询
   select * from table_name where a like '%As'   //全表查询
   select * from table_name where a like '%As%'  //全表查询
   ```



4. 匹配范围值

   ```sql
   select * from table_name where  a > 1 and a < 3
   ```

   可以对最左边的列进行范围查询

   ```sql
   select * from table_name where  a > 1 and a < 3 and b > 1;
   ```

   多个列同时进行范围查找时，只有对索引最左边的那个列进行范围查找才用到 B+Tree 索引，也就是只有 a 用到索引

   在 `1 < a < 3` 的范围内 b 是无序的，不能用索引，找到 `1 < a < 3` 的记录后，只能根据条件 `b > 1` 继续逐条过滤



5. 精确匹配某一列并范围匹配另外一列

   ```sql
   select * from table_name where a = 1 and b > 3;
   ```

   如果左边的列是精确查找的，右边的列可以进行范围查找



6. 排序

   一般情况下，我们只能把记录加载到内存中，再用一些排序算法，比如快速排序，归并排序等在内存中对这些记录进行排序，有时候查询的结果集太大不能在内存中进行排序的话，还可能暂时借助磁盘空间存放中间结果，排序操作完成后再把排好序的结果返回客户端。

   MySQL中把这种在内存中或磁盘上进行排序的方式统称为文件排序。文件排序非常慢，但如果 `ORDER BY` 子句用到了索引列，就有可能省去文件排序的步骤。

   ```sql
   select * from table_name order by a,b,c limit 10;
   ```

   因为 B+Tree 索引本身就是按照上述规则排序的，所以可以直接从索引中提取数据，然后进行回表操作取出该索引中不包含的列就好了。

   `ORDER BY` 的子句后面的顺序也必须按照索引列的顺序给出，比如以下顺序就没有用到索引

   ```sql
   select * from table_name order by b,c,a limit 10;
   ```

   以下则用到了部分索引

   ```sql
   select * from table_name order by a limit 10;
   select * from table_name order by a,b limit 10;
   ```

   联合索引左边列为常量，后边的列排序可以用到索引

   ```sql
   select * from table_name where a =1 order by b,c limit 10;
   ```

   



## 删除百万量级的数据

由于索引需要额外的维护成本，因为索引文件是单独存在的文件，所以当我们对数据的增加、修改、删除，都会产生额外的对索引文件的操作,这些操作需要消耗额外的 I/O，会降低 CRUD 的执行效率。

删除数据的速度和创建的索引数量是成正比的，所以想要删除百万数据的时候可以先删除索引。

1. 删除索引
2. 删除数据
3. 重建索引



# 日志系统🐬

## redo log

重做日志（redo log）确保事务的持久性。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。



## undo log

回滚日志（undo log）保存了事务发生之前的数据的版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读



## bin log

用于复制，在主从复制中，从库利用主库上的 bin log 进行重播，实现主从同步。 







# MySQL调优🐬

## 数据类型优化

- 尽可能选择合适的数据类型的长度，如果字段的长度很大，那么读取数据也需要更多的 I/O，所以合理的字段长度也能提升数据库的性能。

- 对于某些文本字段，例如 "省份" 或者 "性别"，我们可以将它们定义为 ENUM 类型。因为在MySQL中，ENUM 类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。



## 索引优化

- 不要用 `like "%xxxx"` ，会导致索引失效，但  `like "xxxx%"`  可以用到索引
- 少用 `or`，用它来连接时会导致索引失效
- `<，<=，=，>，>=，BETWEEN，IN` 可用到索引，`<>，not in ，!=` 则不行，会导致全表扫描

- 索引应建立在那些将用于 `JOIN` 、`WHERE` 、`ORDERBY` 排序的字段上，这样可以避免 FileSort





## 查询优化

小表驱动大表













# 主从复制🐬

## 概念

主从同步指一台服务器充当主数据库服务器，另一台或多台服务器充当从数据库服务器，主服务器中的数据自动复制到从服务器之中。对于多级复制，数据库服务器即可充当主机，也可充当从机。

生产环境中，数据库大多都是读操作，所以部署一主多从架构，主数据库负责写操作，并做双击热备，多台从数据库做负载均衡，负责读操作，并通过数据复制机制，在主节点和只读节点之间进行数据的实时同步，保证主从节点的数据一致性。



## 主从复制的优点

1. 实现服务器的负载均衡

即可以通过在主服务器和从服务器之间切分处理客户查询的负荷，从而得到更好的客户相应时间，一般有两种思路：

- 主服务器上只实现数据的更新操作。

  包括数据记录的更新、删除、新建等等作业。而不关心数据的查询作业。数据库管理员将数据的查询请求全部转发到从服务器中。这在某些应用中会比较有用。

- 主服务器上与从服务器切分查询的作业。

  在这种思路下，主服务器不单单要完成数据的更新、删除、插入等作业，同时也需要负担一部分查询作业。而从服务器的话，只负责数据的查询。当主服务器比较忙时，部分查询请求会自动发送到从服务器重，以降低主服务器的工作负荷。



2. 通过复制实现数据的异地备份

可以定期的将数据从主服务器上复制到从服务器上，实现了数据的异地备份。

在传统的备份体制下，是将数据备份在本地。此时备份作业与数据库服务器运行在同一台设备上，当备份作业运行时就会影响到服务器的正常运行。有时候会明显的降低服务器的性能。同时，将备份数据存放在本地，也不是很安全。如硬盘因为电压等原因被损坏或者服务器被失窃，此时由于备份文件仍然存放在硬盘上，数据库管理员无法使用备份文件来恢复数据。



3. 故障时取代主服务器

   当主服务器出现问题时，数据库管理员可以马上让从服务器作为主服务器，用来数据的更新与查询服务。

   双击热备：应用于服务器的一种解决方案，其构造思想是主机和从机通过 TCP/IP 网络连接，正常情况下主机处于工作状态，从机处于监视状态，一旦从机发现主机异常，从机将会在很短的时间之内代替主机，完全实现主机的功能。

   - 部分取代主服务器

     主服务器故障之后，从服务器取代了主服务器的位置，但是对其可以采取的操作做了一些限制。

     如仍然只能够进行数据的查询，而不能够进行数据的更新、删除等操作。这主要是从数据的安全性考虑。例如银行系统在升级的过程中，只能够查询余额而不能够取钱就是这个原因。

   - 完全取代主服务器

     当从服务器切换为主服务器之后，其地位完全与原先的主服务器相同。此时可以实现对数据的查询、更新、删除等操作。



## 主从复制原理

MySQL 主从复制的基础是主服务器对数据库修改记录二进制日志（Binary Log），从服务器通过主服务器的二进制日志自动执行更新。

一句话表示就是，主数据库做什么，从数据库就跟着做什么。

- 基于语句的复制 ：主库把 SQL 语句写入到 Binary Log 中，完成复制
- 基于行数据的复制：主库把每一行数据变化的信息作为事件，写入到 Binary Log，完成复制
- 混合复制：上面两个结合体，默认用语句复制，出问题时候自动切换成行数据复制



和上面相对应的日志格式也有三种: STATEMENT 、ROW 、MIXED

- STATEMENT

  每一条修改数据的SQL语句会记录到 Binary Log 中。优点是并不需要记录每一条SQL语句和每一行的数据变化，减少了 binlog 日志量，节约IO，提高性能。缺点是在某些情况下会导致 master-slave 中的数据不一致

  > 如 sleep()、last_insert_id()、user-defined functions(udf) 等会出现问题

- ROW

  不记录每条SQL语句的上下文信息，仅需记录哪条数据被修改了，修改成什么样了。而且不会出现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的问题，缺点是会产生大量的日志，尤其是修改表结构的时候会让日志暴涨。

- MIXED

  以上两种模式的混合使用，一般的复制使用 STATEMENT 模式保存 Binary Log ，对于 STATEMENT 模式无法复制的操作使用 ROW 模式保存 Binary Log ，MySQL会根据执行的SQL语句选择日志保存方式。



工作流程：

1. Master 数据库只要发生变化，立马记录到 Binary Log 日志文件中

2. Slave 数据库启动一个 I/O Thread 连接 Master数据库，请求 Master 变化的二进制日志

3. Slave I/O 获取到二进制日志，保存到自己的 Relay log 日志文件中

4. Slave 有一个 SQL thread 定时检查 Relay log 是否变化，变化那么就更新数据







# 分区分表分库🐬

## 分库

分库是根据业务不同把相关的表切分到不同的数据库中，比如web、bbs、blog等库。如果业务量很大，还可将切分后的库做主从架构，进一步避免单个库压力过大。



## 分表

数据量的日剧增加，数据库中某个表有几百万条数据，导致查询和插入耗时太长，可以把单个表拆分成多个小表，来减轻单个表的压力，提高处理效率。

- 垂直拆分：把原来的一个很多字段的表拆分多个表，解决表的宽度问题。可以把不常用的字段单独放到一个表中，也可以把大字段独立放一个表中，或者把关联密切的字段放一个表中。

- 水平拆分：把原来一个表拆分成多个表，每个表的结构都一样，解决单表数据量大的问题。



## 分区

分区就是把一张表的数据根据表结构中的字段（range、list、hash等）分成多个区块，这些区块可以在一个磁盘上，也可以在不同的磁盘上，分区后，表面上还是一张表，但数据散列在多个位置，这样一来，多块硬盘同时处理不同的请求，从而提高磁盘I/O读写性能，实现比较简单。





# EXPLAIN🐬
