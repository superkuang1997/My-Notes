

# 概念✨

## 数据结构概念

数据结构是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成。



## 数据的存储结构

数据的存储结构主要分为两类：

- 顺序结构

  数组是连续存储的，可以随机访问，通过索引快速找到对应元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 $O(N)$；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 $O(N)$ 。

- 链式结构

  链表是靠指针指向下一个元素的位置，所以不存在数组的扩容问题；如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度 $O(1)$ 。但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。



## 数据的逻辑结构

数据的逻辑结构主要分为四类：

- 集合结构
- 线性结构
- 树形结构
- 图形结构





## 大O表示法

n表示问题的规模，T(n)的精确值并不重要，重要的是T(n)中起决定性作用的主导部分

例如`T(n)=5n^2+27n+100` 时间复杂度为`O(n^2) `









# 线性结构✨

## 概念

线性结构是一种有序数据项的集合，除了第一个没有前驱，最后一个没有后继以外，**每个数据项都有唯一的前驱和后继**。线性是指的逻辑上的线性，即只要数据的保存满足了一对一关系，除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接没有例外；

不同线性结构的关键区别在于**数据项增减的方式**。

线性表分为顺序存储和链式存储两种方式。

对于顺序存储，存储结构为顺序表；对于链式存储，存储结构为单链表、双链表、循环链表、静态链表等。

以下结构的共同点在于数据项之间只存在先后的次序关系，不同点在于数据的增减方式。



## 顺序存储

顺序表，使用数组实现，用一段内存上连续的存储单元依次存储线性表的数据元素。数组大小有两种方式指定，一是静态分配，二是动态扩展。

时间性能：查找 `O(1)` 、插入和删除 `O(n)`

空间性能：需要预分配存储空间，分大了浪费，小了容易发生溢出



## 链式存储

链表的定义是递归的，它或者为空，或指向另一个节点node的引用，这个节点含有下一个节点的引用。

与顺序存储相比，允许存储空间不连续，插入、删除元素不需要移动大量元素，只需要修改指针即可，但查找某个元素，只能从头遍历整个链表。

时间性能：查找 `O(n)` 、插入和删除 `O(1)`

空间性能：不需要分配存储空间，只要有就可以分配，元素个数不受限制



# 数组✨



# 链表✨

## 快慢指针

链表长度为偶数：slow -> 中间靠后的一个，fast  -> null

链表长度为奇数：slow -> 中间，fast -> 最后一个节点

```java
ListNode slow, fast;
slow = fast = head;
while (fast != null && fast.next != null) {
    slow = slow.next;
    fast = fast.next.next;
}
```



# 栈✨

## 栈的概念

栈是一种有次序的数据项集合，在栈中，数据项的加入和移除都仅发生在同一端。栈的一端叫栈顶，另一端叫栈底，距离栈底越近的数据项，留在栈中的时间就越长而最新加入栈的数据项会被最先移除，这种次序通常称为 "后进先出"。



## 栈的实现





## 栈的应用





# 队列✨

## 队列的概念

队列是一种有次序的数据集合，其特征是新数据项的添加总发生在队尾，而现存数据项的移除总发生在队首，这种次序通常称为 "先进先出" 。



## 队列的实现

```java
public interface Queue<E> extends Collection<E> {

    boolean add(E e);  // 如果超出队列限制，会抛出异常

    boolean offer(E e);  // 如果超出队列限制，不会抛出异常而是返回false

    E remove(); // 移除队首的元素，如果队列为空会抛出异常

    E poll();  // 移除队首的元素，如果队列为空不会抛出异常

    E element();  // 查看队首的元素，如果队列为空会抛出异常

    E peek();  // 查看队首的元素，如果队列为空不会抛出异常
}
```





## 双端队列

双端队列 Deque 是一种有次序的数据集，跟队列相似，其两端可以称作队首与队尾，但 Deque 中数据项既可以从队首加入，也可以从队尾加入，同时数据项也可以从两端移除。

某种意义上说，双端队列集成了栈和队列的能力。



## 双端队列的实现

以下是Java中对Deque的实现

```java
public interface Deque<E> extends Queue<E> {

    void addFirst(E e);

    void addLast(E e);

    boolean offerFirst(E e);

    boolean offerLast(E e);

    E removeFirst();

    E removeLast();

    E pollFirst();

    E pollLast();

    E getFirst();

    E getLast();

    E peekFirst();

    E peekLast();

    boolean removeFirstOccurrence(Object o);

    boolean removeLastOccurrence(Object o);

    // *** Queue methods ***

    boolean add(E e);

    boolean offer(E e);

    E remove();

    E poll();

    E element();

    E peek();


    // *** Stack methods ***

    void push(E e);

    E pop();


    // *** Collection methods ***

    boolean remove(Object o);

    boolean contains(Object o);

    public int size();

    Iterator<E> iterator();

    Iterator<E> descendingIterator();

}

```





# 递归✨

## 递归三要素

1. 递归函数的作用是什么？ 首先要明确递归函数的功能
2. 递归停止的条件是什么？ 当参数为某个值时，递归结束
3. 从某层到下一层的关系是什么？ 即如何缩小问题的规模，如何处理递归层级之间的关系



## 递归的关键

明确递归函数的「定义」是什么，然后相信这个定义，利用这个定义推导最终结果，绝不要跳入递归的细节。

树的递归算法

### 自顶而下递归

先搞清楚当前 root 节点该做什么，然后根据函数定义递归调用子节点，递归调用会让子节点做相同的事情。



### 自底而上递归

递归的过程：入栈 -> 入栈 -> 到达递归停止条件 -> 出栈 -> 出栈

要站在最后一次出栈的角度思考，要想着之前的 n 步递归已经完成了，再次基础上确定递归函数的要做的事情，不要陷入递归的细节。



## 分治策略

解决分治问题的时候，思路就是想办法把问题的规模减小，有时候减小一个，有时候减小一半，然后将每个小问题的解以及当前的情况组合起来得出最终的结果。

没有子问题重复出现，这是动态规划和分治的区别。



## 贪心策略

1. 关于最优子结构

- 贪心：每一步的最优解一定包含上一步的最优解，上一步之前的最优解无需记录

- 动态规划：全局最优解中一定包含某个局部最优解，但不一定包含上一步的局部最优解，因此需要记录之前的所有的局部最优解

2. 结果正确性

- 贪心不能保证求得的最后解是最佳的，复杂度低
- 动态规划本质是穷举法，可以保证结果是最佳的，复杂度高





# 查找✨

## 顺序查找

时间复杂度：$O(n)$



## 二分查找

二分查找的前提条件：数据集有序

二分查找的时间复杂度： $O(log_2n)$

```java
public int search(int[] nums, int target) {
    int lo = 0, hi = nums.length - 1, mid = 0;
    while (lo <= hi) {
        mid = lo + ((hi - lo) >> 1);
        if (nums[mid] == target) {
            return mid;
        }
        if (nums[mid] < target) {
            lo = mid + 1;
        } 
        else {
            hi = mid - 1;
        }
    }
    return -1;
}
```

要注意判断条件

- 如果是小于等于，即 `lo <= hi` ，表示：在区间只有 1 个元素的时候，依然需要进行相关逻辑的判断。迭代到最后一定有 lo == hi == mid，那么需要一个出口才能结束循环。

- 如果没有等于号，即 `lo < hi`，那么迭代到 lo == hi 就不会再进入下一次循环了，即退出循环时一定有  lo == hi 成立，好处是不需要判断到底是返回 lo 还是返回 hi





### 旋转数组的二分查找

一般两个思路：

思路 1：看看当前搜索区间的 左边界 和「中间数」，是不是可以缩小搜索区间的范围；
思路 2：看看当前搜索区间的 右边界 和「中间数」，是不是可以缩小搜索区间的范围；

但到底选择左边界还是右边界，还是都可以选择？

例如 LC-153，要求查找旋转数组最小值

case1：[1, 2, 3, 4, 5] 

case2： [2, 3, 4, 5, 1] 

对于以 left 为判断依据：

case1 和 case2 都有 mid > left，但是最小值一个在左边，一个在右边，无法确定往哪边缩小，排除

对于以 right 为判断依据：

case1 有 mid < right，说明从 mid 到 right 是递增的，一定没有 target，往 mid 左边缩小

case2  有 mid > right，所以 mid 左边的数是递增的且比 right 大，一定没有target，往 mid 右边缩小

<img src="http://store.secretcamp.cn/uPic/IMG_276098769D9D-1202108121154471628740487zbQ7AhzbQ7Ah.jpeg" alt="IMG_276098769D9D-1" style="zoom:25%;" />





# 排序✨

<img src="http://store.secretcamp.cn/uPic/image-20210314201740375202103142017401615724260SGMTKgSGMTKg.png" alt="image-20210314201740375" style="zoom: 50%;" />



## 排序算法的稳定性

假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中， r[i] = r[j] ，且 r[i] 在 r[j] 之前，而在排序后的序列中，r[i] 仍在 r[j] 之前，则称这种排序算法是稳定的；否则称为不稳定的。



## 冒泡排序

冒泡排序的算法思路在于对无序表进行多趟比较交换

- 每趟包括了多次两两相邻比较，并将逆序的数据项互换位置，最终能将本趟的最大项就位

- 经过 n-1 趟比较交换，实现整表排序
- 第一趟需要比较 n-1 次，第二趟需要比较 n-2 次，以此类推并减少到 1

- 每趟的过程类似于 "气泡" 在水中不断上浮到水面的经过

<img src="http://store.secretcamp.cn/uPic/image-20201225092432920202012250924331608859473fQFkULfQFkUL.png" alt="image-20201225092432920" style="zoom: 40%;" />

算法分析：

- 比较次数是 1 ~ n-1 的累加 $\frac{1}{2}n^2-\frac{1}{2}n$，时间复杂度是 $O(n^2)$
- 每次交换包括三次赋值，次数为 $\frac{3}{2}n^2-\frac{3}{2}n$，时间复杂度是 $O(n^2)$
- 最好情况下，数组是顺序，只需要比较不需要交换，时间复杂度是 $O(n^2)$
- 最坏情况下，数组是逆序，每次都要比较和交换，时间复杂度是 $O(n^2)$
- 平均时间复杂度为 $O(n^2)$，无序表初始数据项的排列状况对冒泡排序的时间复杂度没有影响



```java
// java
public static void bubbleSort(int[] array) {
    for (int passnum = array.length - 1; passnum > 0; passnum--) {
        for (int i = 0; i < passnum; i++) {
            int temp;
            if (array[i] > array[i + 1]) {
                temp = array[i];
                array[i] = array[i + 1];
                array[i + 1] = temp;
            }
        }
    }
}
```



## 选择排序

选择排序对冒泡排序进行了改进，保留了其基本的多趟比对思路，每趟都使当前最大项就位。

但选择排序对交换进行了削减，相比起冒泡排序进行多次交换， 每趟仅进行1次交换，记录最大项的所在位置，最后再跟本趟最后一项元素交换。

算法分析：

- 比对次数不变，还是 $O(n^2)$
- 交换次数则减少为 $O(n)$

<img src="http://store.secretcamp.cn/uPic/image-20201225095840022202012250958401608861520ERg7P2ERg7P2.png" alt="image-20201225095840022" style="zoom: 50%;" />

```java
public static void selectSort(int[] array) {
    int passnum = array.length - 1;
    while (passnum > 0) {
        int indexOfMax = 0;
        for (int i = 1; i <= passnum; i++) {
            if (array[i] > array[indexOfMax]) {
                indexOfMax = i;
            }
        }
        int temp = array[indexOfMax];
        array[indexOfMax] = array[passnum];
        array[passnum] = temp;
        passnum--;
    }
}
```



## 插入排序

插入排序维持一个已排好序的子列表，其位置始终在列表的前部，然后逐步扩大这个子列表直到全表

算法分析：

- 最差情况下，每趟都与子列表中所有项进行比对，时间复杂度为 $O(n^2)$
- 最好情况下，列表已经排好序，每趟仅需1次比对，总次数是 $O(n)$



<img src="http://store.secretcamp.cn/uPic/image-20201225102452760202012251024521608863092BlVcjRBlVcjR.png" alt="image-20201225102452760" style="zoom:50%;" />





```java
public static void insertSort(int[] array) {
    for (int i = 1; i < array.length; i++) {
        int position = i;
        int currentValue = array[position];
        while (position > 0 && array[position - 1] > currentValue) {
            array[position] = array[position - 1];
            position--;
        }
        array[position] = currentValue;
    }
}
```





## 希尔排序

希尔排序是对插入排序的改进

算法分析：

- 根据间隔将列表划分为多个子列表，分别对每个子列表带使用带间隔的插入排序
- 子列表的间隔 n/2，n/4，n/8……

- 对子列表进行排序之后，列表整体已经接近有序，但不是完全有序，最后一次，使用标准的插入排序

- 时间复杂度最好为 $O(n)$ ，最差为 $O(n^2)$ ，平均为$O(n^{3/2})$

<img src="http://store.secretcamp.cn/uPic/image-202012251624527412020122516245216088846928tNJTC8tNJTC.png" alt="image-20201225162452741" style="zoom:50%;" />

```java
// 希尔排序
public static void shellSort(int[] list) {
    int subListCount = list.length / 2;
    while (subListCount > 0) {
        for (int start = 0; start < subListCount; start++) {
            insertSortWithGap(list, start, subListCount);
        }
        subListCount /= 2;
    }
}

// 带间隔的插入排序
public static void insertSortWithGap(int[] list, int start, int gap) {
    for (int i = start; i < list.length; i += gap) {
        int position = i;
        int currentValue = list[position];
        while (position > start && list[position - gap] > currentValue]) {
            list[position] = list[position - gap];
            position -= gap;
        }
        list[position] = currentValue;
    }
}
```



## 归并排序

1. 递归的基本结束条件：数据表仅有1个数据项，自然是排好序的；

2. 缩小规模：将数据表分裂为相等的两半，规模减 为原来的二分之一；

3. 调用自身：将两半分别调用自身排序，然后将分 别排好序的两半进行归并，得到排好序的数据表

<img src="http://store.secretcamp.cn/uPic/image-20201225163107957202012251631081608885068fuZOr2fuZOr2.png" alt="image-20201225163107957" style="zoom:50%;" />

<img src="http://store.secretcamp.cn/uPic/image-20201225163127228202012251631271608885087x332vex332ve.png" alt="image-20201225163127228" style="zoom:53%;" />

算法分析：

- 归并排序是递归算法，思路是将数据表持续分裂为两半，对两半分别进行归并排序

- 分裂的过程，时间复杂度为 $O(log_2n)$
- 归并的过程，相对于分裂的每个部分，所有数据项都会被比较和放置一次，其时间复杂度是 $O(n)$
- 总体时间复杂度为 $O(nlog_2n)$

- 归并排序算法使用了额外一倍的存储空间用于归并



```java
public static void mergeSort(int[] list) {
    // 递归结束条件 list.length == 1
    if (list.length == 1) {
        return;
    }

    int mid = list.length / 2;
    // 分裂，并调用自身
    int[] leftBranch = Arrays.copyOfRange(list, 0, mid);
    int[] rightBranch = Arrays.copyOfRange(list, mid, list.length);
    mergeSort(leftBranch);
    mergeSort(rightBranch);

    // 左分支计数器
    int i = 0;
    // 右分支计数器
    int j = 0;
    // 整体归并计数器
    int k = 0;

    // 归并
    while (i < leftBranch.length && j < rightBranch.length) {
        if (leftBranch[i] < rightBranch[j]) {
            list[k] = leftBranch[i];
            i++;
        } else {
            list[k] = rightBranch[j];
            j++;
        }
        k++;
    }

    // 处理余项
    while (i < leftBranch.length) {
        list[k] = leftBranch[i];
        i++;
        k++;
    }
    while (j < rightBranch.length) {
        list[k] = rightBranch[j];
        j++;
        k++;
    }

}
```



## 快速排序

快速排序的思路是依据一个 "中值" 数据项来把数据表分为两半：小于中值的一半和大于中值的一半，然后每部分分别进行快速排序。

- 首先设定列表中的第一个数为中值
- 设置左右标，左标向右移动，右标向左移动
  - 左标一直向右移动，碰到比中值大的就停止
  - 右标一直向左移动，碰到比中值小的就停止
  - 将左右标所指的数据项交换
- 继续以上步骤，直到左标移动到右标右侧，停止移动
- 此时右标所处应该是中值的新位置，将右标与中值位置交换
- 分裂完成，列表的左半部分比中值小，右半部分比中值大
- 对左半部和右半部分别递归调用快速排序

<img src="http://store.secretcamp.cn/uPic/image-20201225174318008202012251743181608889398sHLm58sHLm58.png" alt="image-20201225174318008" style="zoom:50%;" />

<img src="http://store.secretcamp.cn/uPic/image-20201225174414617202012251744141608889454dxmQEJdxmQEJ.png" alt="image-20201225174414617" style="zoom:47%;" />



算法分析：

- 分裂
  - 如果分裂总能将数据表分为相等两部分，则为 $O(log_2n)$ 
  - 如果中值所在分裂点过于偏离中部，例如某列表已经是正序排列，那么左标不移动，但右标每次都会移动到左标左侧，交换后中值的位置不变，仍处于最左侧，那么分裂的时间复杂度为 $O(n)$

- 移动： 移动时需要将每项都与中值进行比对，为 $O(n)$

总时间复杂度：最优为 $O(nlog_2n)$ ，最差为 $O(n^2)$



稳定性分析：

快速排序是不稳定的，在中值元素和右标交换的时候，很有可能把前面的元素的稳定性打乱。



```java
public static void quickSort(int[] nums) {
    partition(nums, 0, nums.length - 1);
}

public static void partition(int[] nums, int first, int last) {
    int pivot = first;
    int left = first + 1;
    int right = last;
    if (first < last) {
        while (true) {
            while (left < last && nums[left] <= nums[pivot]) left++;
            while (right > first && nums[right] >= nums[pivot]) right--;
            if (left >= right) {
                swap(nums, pivot, right);
                break;
            } else swap(nums, left, right);
        }
        partition(nums, first, right - 1);
        partition(nums, right + 1, last);
    }
}

private static void swap(int[] nums, int a, int b) {
    int tmp = nums[a];
    nums[a] = nums[b];
    nums[b] = tmp;
}
```



```java
public static void quicksort(int[] nums) {
    partition(nums, 0, nums.length - 1);
}

public static void partition(int[] nums, int lo, int hi) {
    if (lo >= hi) return;
    int mid = nums[lo];
    int i = lo, j = hi + 1;
    while (true) {
        while (++i < hi && nums[i] < mid);
        while (--j > lo && nums[j] > mid);
        if (i >= j) {
            break;
        }
        swap(nums, i, j);
    }
    swap(nums, lo, j);
    partition(nums, lo, j - 1);
    partition(nums, j + 1, hi);

}

private static void swap(int[] nums, int i, int j) {
    int tmp = nums[i];
    nums[i] = nums[j];
    nums[j] = tmp;
}
```



## 堆排序

算法分析：

- 时间复杂度： $O(log_2n)$ 



稳定性分析：

堆排序是不稳定的



```java
public static void heapSort(int[] arr) {
    // 1、构建大顶堆
    for (int i = arr.length / 2 - 1; i >= 0; i--) {
        //从第一个非叶子节点从下至上，从右至左调整结构
        adjustHeap(arr, i, arr.length);
    }
    //2、调整堆结构+交换堆顶元素与末尾元素
    for (int j = arr.length - 1; j > 0; j--) {
        swap(arr, 0, j);//将堆顶元素与末尾元素进行交换
        adjustHeap(arr, 0, j);//重新对堆进行调整
    }

}

private static void adjustHeap(int[] arr, int i, int length) {
    int temp = arr[i];
    for (int k = i * 2 + 1; k < length; k = k * 2 + 1) {	//从i结点的左子结点开始，也就是2i+1处开始
        if (k + 1 < length && arr[k] < arr[k + 1]) {
            k++;
        }
        if (arr[k] > temp) {	//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）
            arr[i] = arr[k];
            i = k;
        } else {
            break;
        }
    }
    arr[i] = temp;//将temp值放到最终的位置
}

private static void swap(int[] arr, int a, int b) {
    int temp = arr[a];
    arr[a] = arr[b];
    arr[b] = temp;
}
```



# 位运算✨

## 按位与

奇数的最后一位一定是 1 ，偶数的最后一位一定是 0

奇数：num & 1 = 1 
偶数：num & 1 = 0 



技巧：

(n−1) ： 二进制数字 n 最右边的 1 变成 0 ，此 1 右边的 0 都变成 1 。
n \& (n - 1)： 二进制数字 n 最右边的 1 变成 0 ，其余不变。



## 按位或





## 按位异或

如果 a、b 两个值不相同，则异或结果为 1 。如果 a、b 两个值相同，异或结果为 0 。

异或的特点：

- 0 ^ 任何数 ＝ 任何数
- 1 ^ 任何数 = 任何数取反
- XOR 运算满足交换律和结合律：a⊕b⊕a = (a⊕a)⊕b = 0⊕b = b



>  速记：男性和女性能生出孩子，否则就不行。

```
True  ⊕ False = True
False ⊕ True  = True
False ⊕ False = False
True  ⊕ True  = False
```

<img src="http://store.secretcamp.cn/uPic/image-20210810123449671202108101234501628570090HtnYJ4HtnYJ4.png" alt="image-20210810123449671" style="zoom:40%;" />







# 动态规划✨

## 要义

解决动态规划问题的核心：找出子问题及其子问题与原问题的关系

明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义。

```python
# 初始化 base case
dp[0][0][...] = base
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```





自顶向下递归 + 备忘录

自底向上的动态规划 + DP Table



## 贪心算法

贪心选择特质是指每一步都做出一个局部最优的选择，最终的结果就是全局最优。

这是一种特殊性质，其实只有一部分问题拥有这个性质。



# Hash✨

## Hash的概念

Hash也称散列，基本原理就是把任意长度的输入，通过映射变成固定长度的输出。这个映射的规则就是对应的 hash 算法，而原始数据映射后的二进制串就是哈希值。



hash的特点：

1. 从 hash 值不可以反向推导出原始的数据
2. 输入数据的微小变化会得到完全不同的 hash 值，相同的数据会得到相同的值 
3. 哈希算法的执行效率要高效，长的文本也能快速地计算出哈希值 
4. hash 算法的散列冲突概率较小

> 由于 hash 的原理是将入空间的值映射成 hash 空间内，而 hash 值的空间远小于输入的空间根据抽屉原理，一定会存在不同的输入被映射成相同输出的情况。





## hash表的实现

- 首先开辟一定长度的，具有连续物理地址的桶数组；

- 当我们插入一个新的键时，哈希函数将决定该键应该分配到哪个桶中，并将该键存储在相应的桶中；

- 当我们想要搜索一个键时，哈希表将使用哈希函数来找到对应的桶，并在该桶中进行搜索。







# 二叉树✨

## 树的概念

树是由若干节点（node）， 以及由节点间两两连接的边（edge）组成，并有如下性质：

- 其中一个节点被设定为根

- 每个节点n（除根节点），都连接一条来自节点p的边，p是n的父节点；

- 每个节点从根开始的路径是唯一的 

- 如果每个节点最多有两个子节点， 这样的树称为 "二叉树"



## 二叉树

一棵二叉树是结点的一个有限集合，该集合或者为空，或者是由一个根节点加上两棵分别称为左子树和右子树的二叉树组成。

- 二叉树的每个结点最多有两棵子树，即二叉树不存在度大于2的结点

- 二叉树的子树有左右之分，其子树的次序不能颠倒

**满二叉树：**在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子节点都在同一层上

**完全二叉树：**如果一棵具有n个结点的二叉树的结构与满二叉树的前n个结点的结构相同，称为完全二叉树



## 二叉树的实现







## 遍历树



<img src="http://store.secretcamp.cn/uPic/%E4%BA%8C%E5%8F%89%E6%A0%91202012271057491609037869IV14ujIV14uj.png" alt="二叉树" style="zoom:50%;" />

### 前序遍历

"中 -> 左 -> 右"

1 -> 2 -> 4 -> 8 -> 9 -> 5 -> 3 -> 6 -> 7

```java
public static void preOrder(BinaryTree tree) {
    if (tree != null) {
        System.out.println(tree.getRoot());
        preOrder(tree.getLeftBranch());
        preOrder(tree.getRightBranch());
    }
}
```



### 中序遍历

"左 -> 中 -> 右"

8 -> 4 -> 9 -> 2 -> 5 -> 1 -> 6 -> 3 -> 7

```java
public static void inOrder(BinaryTree tree) {
    if (tree != null) {
        preOrder(tree.getLeftBranch());
        System.out.println(tree.getRoot());
        preOrder(tree.getRightBranch());
    }
}
```



### 后续遍历

"左 -> 右 -> 中"

8 -> 9 -> 4 -> 5 -> 2 -> 6 -> 7 -> 3 -> 1

```java
public static void postOrder(BinaryTree tree) {
    if (tree != null) {
        preOrder(tree.getLeftBranch());
        preOrder(tree.getRightBranch());
        System.out.println(tree.getRoot());
    }
}
```



后序遍历的倒序为 "中 -> 右 -> 左"，是前序遍历 "中 -> 左 -> 右" 的镜像



## 二叉树的缺点

尽管二叉树的操作效率较高，但是也存在问题

- 由于构建二叉树时需要把数据从某个地方（数据库、文件等）加载到内存，如果节点少，那没什么问题，但如果有海量节点，在构建二叉树时，每个节点都会进行一次 IO操作，那么构建二叉树的速度就会很慢。
- 如果二叉树有海量节点，那么树的高度也特别高，当进行增加、删除、左旋、右旋节点等操作时，速度也会变慢。



## 多叉树的概念

二叉树中每个结点有一个数据项，最多有两个子节点，如果允许树的每个节点可以有两个以上的子节点，那么这个树就称为n阶的多叉树，或者称为n叉树。

- 多叉树每个节点有更多的数据项，那么相较于二叉树节点数量会变少。
- 多叉树每个节点可以有多个子节点，那么相较于二叉树高度也会降低。





# 二叉堆✨

## 二叉堆的概念

堆又指二叉堆，本质上是一种完全二叉树，它分为两个类型：

- 最小堆（小根堆）：任何一个父节点的值，都小于等于它左右孩子节点的值。
- 最大堆（大根堆）：任何一个父节点的值，都大于等于它左右孩子节点的值。

完全二叉树：若设二叉树的深度为 k ，除第 k 层外，其它各层（1～k-1）的结点数都达到最大个数，第 k 层所有的结点都连续集中在最左边。

<img src="http://store.secretcamp.cn/uPic/image-20210109090650538202101090906511610154411kNu9jokNu9jo.png" alt="image-20210109090650538" style="zoom: 33%;" />



二叉堆的根节点叫做 "堆顶"，符合 "堆" 性质的二叉树，其中任何一条路径，均是一个已排序数列

> 这里的 "堆" 是指数据结构中的堆，而不是内存模型中的堆



## 二叉堆的实现

完全二叉树由于其特殊性，可以用非嵌套 列表，以简单的方式实现。

二叉堆一般都通过 "数组" 来实现。数组实现的二叉堆，父节点和子节点的位置存在一定的关系。有时候，我们将"二叉堆的第一个元素"放在数组索引为0的位置，有时候放在1的位置，它们的本质一样，只是实现上稍微有一些区别。

假设"第一个元素"在数组中的索引为 0 的话，则父节点和子节点的位置关系如下：

- 索引为 i 的左孩子的索引是 $2*i+1$

- 索引为 i 的右孩子的索引是 $2*i+2$

- 索引为 i 的父结点的索引是 $floor((i-1)/2);$

 

假设"第一个元素"在数组中的索引为 1 的话，则父节点和子节点的位置关系如下：

- 索引为 i 的左孩子的索引是 $2*i$
- 索引为 i 的右孩子的索引是 $2*i+1$
- 索引为 i 的父结点的索引是 $floor(i/2)$



<img src="http://store.secretcamp.cn/uPic/image-20210710175845716202107101758461625911126u87HCCu87HCC.png" alt="image-20210710175845716" style="zoom:50%;" />



如果向二叉堆中添加新的节点，必须要满足以下要求：

- 保持完全二叉树的性质：新节点必须被添加到数组的末尾
- 保持堆结构的性质：从堆顶出发的任意路径上的所有节点都是有序的



### 上浮

新节点加在列表末尾，显然无法保持堆次序，所以需要将新节点沿着路径来 "上浮" 到其正确位置

"上浮" 路径的选择：搜索当前节点的父节点，如果父节点的值大于当前节点，则交换，一直上浮到根节点。



### 下沉

删除数组中的节点，显然破坏了树的结构，为了保持树的结构，需要用一个节点来替换到被删除的位置。

为了保持完全二叉树的性质，显然用最后一个叶节点替换是最好的选择，所以将最后一个节点移动到被删除的位置，之后，为了保持堆次序，需要将新节点沿着路径 "下沉" 到其正确位置。

"下沉" 路径的选择：下沉节点如果大于子节点，那么选择较小的子节点交换下沉，一直下沉到叶节点。



 

# 二叉搜索树✨

## 二叉搜索树的概念

二叉搜索树（BST，binary search tree）是具有下列性质的二叉树：

- 若它的左子树不空，则左子树上所有结点的值均 小于 它的根节点的值；

- 若它的右子树上所有结点的值均 大于 它的根节点的值；

- 它的左、右子树也分别为二叉排序树。

对BST进行中序遍历，得到的结果是有序的。



## 二叉搜索树的实现

### 添加节点

1. 首先看bst是否为空，如果一个节点都没有，那么第一个节点将成为根节点root

2. bst不为空，则调用一个递归方法 put 来放置节点

   - 如果 key > currentNode，那么put到左子树

   - 如果 key < currentNode，那么put到右子树

### 查找节点

1. 首先看bst是否为空，如果为空则直接返回null

2. bst不为空，则调用一个递归方法 get 来查找节点

   - 如果 key = currentNode，则返回当前节点

   - 如果 key > currentNode，则对右子树调用get方法

   - 如果 key < currentNode，则对左子树调用get方法

3. 如果没有找到，则从栈底向栈顶返回null

### 删除节点

从bst中移除一个节点，还要求仍然保持bst的性质，分以下3种情形：

- 这个节点没有子节点 

- 这个节点有一个子节点 

- 这个节点有两个子节点

<img src="http://store.secretcamp.cn/uPic/image-202101061053198732021010610532016099016004wEFrU4wEFrU.png" alt="image-20210106105319873" style="zoom: 50%;" />





1）对于没有子节点的情形，最为简单，直接删除该节点即可。

2）对于只有一个子节点的情形，只需删除该节点，并处理好子节点与父节点的关系即可。

3）对于有两个子节点的情形，这时无法简单地将某个子节点上移替换被删节点，但可以找到另一个合适的节点来替换被删节点。

这个节点被称为 后继节点（successor）或者 前驱节点（predecessor），后继节点是其右子树中key最小的节点，即大于当前节点的所有节点中的最小值，前驱结点是当前节点左子树中key最大的节点，即小于当前节点的所有节点中的最大值。

以后继节点为例分析：

此时后继节点一定是叶节点或者仅有右子节点，因为如果后继节点有左子节点，那么它的左子节点才应该是后继节点。

<img src="http://store.secretcamp.cn/uPic/image-20210106110642846202101061106431609902403MG0c3zMG0c3z.png" alt="image-20210106110642846" style="zoom: 33%;" />





## 二叉搜索树的性能分析

二叉搜索树的性能决定因素在于树的高度，而其高度又受数据项插入顺序的影响。

- 如果key的列表是随机分布，那么大于和小于根节点key的节点大致相等，那么bst的高度就是 $log_2n$，这样的树就是平衡树，此时put方法的性能为 $O(log_2n)$

- 如果按照从小到大顺序插入的话，这时候put方法的性能为 $O(n)$，此时bst会退化成链表。







# AVL树✨



## AVL树的概念

平衡二叉树（Self-balancing binary search tree）是基于二分法的策略提高数据的查找速度的二叉树的数据结构；

它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树，同时，平衡二叉树必定是二叉查找树。



AVL树是最先发明的自平衡二叉查找树，在AVL树中任何节点的两个子树的高度最大差别为1，增加和删除可能需要通过一次或多次旋转来重新平衡这个树。AVL树得名于发明者的名字缩写：G.M. Adelson-Velskii and E.M. Landis





## AVL树的实现

AVL树的实现中，需要对每个节点跟踪平衡因子（balance factor）

平衡因子是根据节点的左右子树的高度来定义的，确切地说，是左右子树高度差：

```
balanceFactor = height(leftSubTree) - height(rightSubTree)
```

- 平衡因子大于0，称为 "左重" left-heavy 
- 平衡因子小于0，称为 "右重" right-heavy 

- 平衡因子等于0，则称作平衡

如果一个二叉查找树中每个节点的平衡因子都在 [-1，0，1] 之间，则把这个二叉搜索树称为平衡树



AVL树与一般的二叉搜索树的区别，仅仅体现在添加节点中。在添加节点的操作中，要保持树中节点的平衡因子在 [-1，0，1] 之间。



### 右重左旋

右重 -> 为了减少右重，将右子节点B提升为子树的根 

左旋 -> 提升之前的右子节点B的key较大，所以提升后将旧根节点A设为新根节点的左子节点

如果左旋前的右子节点B存在左子节点D，那么该节点的值一定大于节点A，左旋后将D作为A的右子节点，注意不能将A作为D的左子节点。

<img src="http://store.secretcamp.cn/uPic/image-20201228173403691202012281734031609148043U0VwT0U0VwT0.png" alt="image-20201228173403691" style="zoom:40%;" />

<img src="http://store.secretcamp.cn/uPic/687474703a2f2f692e696d6775722e636f6d2f363877536c58392e6769662020122917054216092327424iwTfh4iwTfh.gif" style="zoom:150%;" />

### 左重右旋

左重 -> 为了减少左重，将左子节点提升为子树的根 

右旋 -> 提升之前的左子节点的key较小，所以提升后将旧根节点设为新根节点的右子节点

如果右旋前的左子节点B已经存在右子节点C，那么该节点的值一定小于节点A，所以右旋后将C作为A的左子节点

<img src="http://store.secretcamp.cn/uPic/image-20201228172424585202012281724241609147464WCou4IWCou4I.png" alt="image-20201228172424585" style="zoom:35%;" />

<img src="http://store.secretcamp.cn/uPic/687474703a2f2f692e696d6775722e636f6d2f446e6e4d4d75642e676966202012291707031609232823CfBMm2CfBMm2.gif" style="zoom:150%;" />

### 旋转的特殊情况

对以下 "右重" 二叉查找树进行左旋操作，仍然不能实现平衡，仅仅是从 "右重" 变成了 "左重"。

<img src="http://store.secretcamp.cn/uPic/image-202012281834188482020122818341916091516596F7z8y6F7z8y.png" alt="image-20201228183418848" style="zoom: 45%;" />



所以，在左旋转之前可以检查右子节点的平衡因子，如果右子节点 "左重" 的话，先对它进行右旋转，再对该子树的根节点实施原来的左旋转。

<img src="http://store.secretcamp.cn/uPic/image-20201228183633620202012281836331609151793HJFROBHJFROB.png" alt="image-20201228183633620" style="zoom:60%;" />

同理，对于 "左重" 二叉查找树，如果左子节点 "右重" 的话，先对它进行左旋转，再实施原来的右旋转。



### 平衡因子分析

<img src="http://store.secretcamp.cn/uPic/image-202012291505342892020122915053416092255341bCZ5Z1bCZ5Z.png" alt="image-20201229150534289" style="zoom:50%;" />

如果所示试一次左旋操作，在操作前后只有B、D的平衡因子发生了改变，A、C、E的平衡因子没有发生改变

现在想知道左旋前后节点B的平衡因子如何变化，分析如下：


$$
oldh_B = h_A - old^h_D = h_A - (1 + max(h_C, h_E))
$$

$$
newh_B = h_A - h_C
$$

$$
newh_B - oldh_B = 1 + max(h_C,h_E) - h_c = 1 + max(0, h_E-h_C) = 1 + max(0, -h_D)
$$

最后可以得到：
$$
newh_B  = oldh_B + 1 - min(0, h_D)
$$

设旧根节点为old，新根节点为new，经过同样的分析，有以下结论：

- 左旋old：$old = old + 1 - min(new,0)$

- 左旋new：$new = new + 1 - max(old，0)$

- 右旋old：$old = old - 1 + max(new,0)$

- 右旋new：$new = new - 1 + min(old,0)$





# 红黑树✨

## AVL树的不足

红黑树属于平衡二叉树，但并不严格，是因为它不是严格控制左、右子树高度或节点数之差小于等于1。

AVL树的要求子树的高度差不超过1，所以在添加节点时经常需要进行旋转操作，这会消耗大量的性能，在实际环境下的应用不如红黑树。

具体分析：

红黑树为什么综合性主要是运用了节点的缓存，《算法》中提到，红黑树等价于2-3树。

其中二节点等价于普通平衡二叉树的节点，三节点本质上是非平衡性的缓存。

当需要再平衡（rebalance）时，增删操作时，二节点与三节点间的转化会吸收不平衡性，減少旋转次数，使再平衡尽快结束。

在综合条件下，增删操作相当时且数据的随机性强时，三节点的非平衡性缓冲效果越明显，因此红黑树的综合性能更优。





## 红黑树的概念

红黑树（Red–black tree）是一种平衡二叉搜索树，它通过颜色的约束来维持着二叉树的平衡。

红黑树的另一种定义是含有红黑链接并满足下列条件的二叉查找树：

- 性质1：每个节点或者是黑色，或者是红色。
- 性质2：根节点是黑色
- 性质3：每个叶节点都是黑色（叶节点指NIL节点）
- 性质4：如果一个节点是红色的，则它的子节点必须是黑色的，即一条路径上不能出现相邻的两个红色结点。
- 性质5：从任一节点到其每个叶节点的所有路径都包含相同数目的黑色节点



性质4和性质5作为约束，可以保证从根节点到叶节点的最长可能路径不多于最短的可能路径的两倍长。

分析：当某条路径最短时，这条路径必然都是由黑色节点构成。当某条路径长度最长时，这条路径必然是由红色和黑色节点相间构成，性质5保证了这两条路就的黑色节点数量相同，所以最长路径的长度是最短路径的两倍。

因此，红黑树大致上是平衡的，但并不严格，因为它不是严格控制左、右子树的高度之差小于等于1

n个节点的红黑树的高度至多是 $2log_2(n+1)$，所以高度在 $O(logN)$ 级别



## 红黑树与2-3-4树的对应关系

红黑树起源于2-3-4树，它的本质其实就是2-3-4树

<img src="http://store.secretcamp.cn/uPic/image-20210104193019676202101041930201609759820okU2XDokU2XD.png" alt="image-20210104193019676" style="zoom: 38%;" />



<img src="http://store.secretcamp.cn/uPic/image-20210106102950414202101061029501609900190iMzWVgiMzWVg.png" alt="image-20210106102950414" style="zoom:40%;" />



2-3-4树转红黑树

<img src="http://store.secretcamp.cn/uPic/image-20210104194747287202101041947471609760867w29M8mw29M8m.png" alt="image-20210104194747287" style="zoom: 43%;" />







## 旋转与颜色调整

通过红黑树的定义，可以看到红黑树本质上还是一颗二叉搜索树，所以，对红黑树的插入删除操作都可以分为两阶段来完成。

第一阶段，将红黑树看成一颗普通的二叉查找树，完成插入删除操作。

第二阶段，通过 `旋转` 以及 `颜色调整` 来使得操作后的树满足红黑树的所有特性。



### 情况一

插入的新节点是红黑树的根节点，这种情况下，直接将新节点的颜色由红色变为黑色，满足红黑树的性质二



### 情况二

新节点的父节点是黑色，性质4和性质5没有受到影响，不需要调整。

<img src="http://store.secretcamp.cn/uPic/image-20210105201544184202101052015441609848944nBrDj3nBrDj3.png" alt="image-20210105201544184" style="zoom: 50%;" />

### 情况三

插入新节点D，性质 4 被打破，节点 D 的父节点 B 和叔叔节点 C 均为红色，祖父节点 A 为灰色

无需旋转，将父节点 B 和叔叔节点 C 转为灰色，将祖父节点 A 转为红色，如果祖父节点 A 是红黑树的根节点，则再次转为灰色

<img src="http://store.secretcamp.cn/uPic/image-20210105193408455202101051934081609846448TDJIw6TDJIw6.png" alt="image-20210105193408455" style="zoom: 40%;" />





### 情况四

插入新节点 C，节点 C 的叔叔节点非红，且父节点 B 和祖父节点 A 均为左重（即偏向同一个方向）

对祖父节点 A 进行右旋操作，再交换新根节点与旧根节点的颜色

<img src="http://store.secretcamp.cn/uPic/image-20210105200642862202101052006431609848403sS09P1sS09P1.png" alt="image-20210105200642862" style="zoom:40%;" />



可能会有以下情况：

以C为根节点的子树中插入了新节点，经过调整后，导致节点C被变为红色，进而导致了以下情况的产生，事实上C有两个黑色的子节点，这样才能保证黑色平衡。

在这种情况下，应该将以C为根节点的子树视为一个整体，正常进行旋转、变色操作即可。

<img src="http://store.secretcamp.cn/uPic/image-20210106104423605202101061044231609901063u8JYCZu8JYCZ.png" alt="image-20210106104423605" style="zoom:50%;" />



### 情况五

插入新节点C，节点C的叔叔节点非红，且祖父节点A左重，父节点B右重（即偏向不同方向）

先对父节点B进行左旋操作，转化为 "情况四"，之后再对祖父节点A右旋操作，并交换颜色

![image-20210105200721316](http://store.secretcamp.cn/uPic/image-20210105200721316202101052007211609848441MgBVmHMgBVmH.png)









# B-Tree✨

## B-Tree的概念

B-Tree 即为B树，B为Balanced，意指平衡，B树是一种多路平衡搜索树。

B-Tree的特点：

- 所有节点关键字是按递增次序排列，并遵循左小右大原则
- 所有叶子节点均在同一层
- 叶子节点除了包含关键字和关键字记录的指针外，也有指向其子节点的指针，只不过其指针地址都为null

<img src="http://store.secretcamp.cn/uPic/image-20210310222113418202103102221131615386073cLfFmRcLfFmR.png" alt="image-20210310222113418" style="zoom: 45%;" />

B-Tree中每个节点包含的关键字增多，层级变少，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理

把节点大小限制和充分使用在磁盘快大小范围，可以减少数据查找的次数和复杂度。

> 磁盘数据存储采用块的形式，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来



## 2-3树

2-3树是一种多叉树，也是一种平衡搜索树，是最简单的B树结构，2-3树是三阶B-Tree

2-3树的特点：

- 所有叶节点都拥有相同的深度（只要是B树都满足这个条件）
- 节点右二节点、三节点构成
  - 有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点，二节点有且仅有一个数据项
  - 有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点，三节点有且仅有两个数据项
- 元素始终保持排序顺序，整体上保持二叉查找树的性质

构建规则：

当按照规则插入一个数到某个节点时，不能满足2-3树的构建要求，就需要拆节点，先向上拆，如果上层满，则拆本层，拆后仍然需要满足2-3树的条件。



## 2-3-4树

2-3-4树是四阶的B-Tree，是一种多路查找树。

2-3-4树的特点：

- 所有叶节点都拥有相同的深度（只要是B树都满足这个条件）
- 节点由二节点、三节点、四节点构成
  - 有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点，二节点有且仅有一个数据项
  - 有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点，三节点有且仅有两个数据项
  - 有四个子节点的节点叫四节点，四节点要么没有子节点，要么有三个子节点，四节点有且仅有三个数据项
- 元素始终保持排序顺序，整体上保持二叉查找树的性质



# B+Tree✨

## B+Tree的概念

B+Tree 是基于 B-Tree 和叶子节点顺序访问指针进行实现，它具有 B-Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。



B+树的特点：

- B+树的非叶节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个非叶节点所能保存的关键字大大增加；
- B+树的叶节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到，所以每次数据查询的次数都一样；
- B+树叶节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。

在B+树中，一个节点中的 $key$ 从左到右非递减排列，如果某个指针的左右相邻的 $key$ 分别是 $key_i$ 和 $key_{i+1}$，且不为 null，则该指针指向节点的所有 $key$ 大于等于 $key_i$ 且小于等于 $key_{i+1}$。

<img src="http://store.secretcamp.cn/uPic/image-20210214151137791202102141511381613286698N08NYdN08NYd.png" alt="image-20210214151137791" style="zoom: 50%;" />



## 与B-Tree的比较

1. B+Tree 的层级更少

   相较于B-Tree，B+Tree每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快；

2. B+Tree 查询速度更稳定

   B+Tree所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定

3. B+Tree 天然具备排序功能

   B+Tree所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B-Tree高。

4. B+Tree 全节点遍历更快

   B+Tree遍历整棵树只需要遍历所有的叶子节点即可，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。

B-Tree相对于B+Tree的优点是，如果经常访问的数据离根节点很近，而B-Tree的非叶子节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比B+Tree快。



## 与红黑树的比较

1. B+Tree有更低的树高

   平衡树的树高 $O(h)=O(log_dN)$，其中d为每个节点的出度。红黑树的出度为2，而B+树的出度一般都非常大，所以红黑树的树高明显比B+树大非常多。

2. 磁盘访问原理

   操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次I/O就能完全载入一个节点。

   如果数据不在同一个磁盘块上，那么通常需要移动制动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取时间。B+树相对于红黑树有更低的树高，进行寻道的次数与树高成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以B+树更适合磁盘数据的读取。

3. 磁盘预读特性

   为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。并且可以利用预读特性，相邻的节点也能够被预先载入。



## 查找删除操作

进行查找操作时，首先在根节点进行二分查找，找到一个key所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出key所对应的data。

插入删除操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性。



# 图论✨

## 图的基本概念

- 顶点

  顶点（vertex）是图的基本组成部分，顶点具有名称标识key，也可以携带数据项value

- 边

  边（edge）作为2个顶点之间关系的表示，边连接两个顶点。边可以是无向或者有向的，相应的图称作 "无向图" 和 "有向图"

- 权重

  为了表达从一个顶点到另一个顶点的 "代价"，可以给边赋权（Weight）

- 图

  一个图（grahy）可以定义为 $G = (V,E)$ ，其中V是顶点的集合，E是边的集合，E中的每条边 $e = (v, w)$ ，其中 v 和 w都是V中的顶点，这表示一堆响铃；



## 广度优先搜索

给定图G，以及开始搜索的起始顶点s

BFS搜索所有从s可到达顶点的边，而且在达到更远的距离k+1的顶点之前，BFS会找到全部距离为k的顶点

BFS需要使用队列来实现：

```java
public void breathFirstSearch(T start) {
    Vertex<T> startVertex = getVertex(start);
    startVertex.setDistance(0);
    startVertex.setPredecessor(null);
    Queue<Vertex<T>> queue = new Queue<>();
    queue.enqueue(startVertex);  // 将起始节点加入队列
    while (queue.size() > 0) {  // ---> 当所有节点出队列后，算法结束
        Vertex<T> item = queue.dequeue();  // 取队首作为当前节点
        Set<Vertex<T>> neighbours = item.getConnections();  // 获取邻接节点并遍历
        for (Vertex<T> neighbour : neighbours) {
            if (neighbour.getColor().equals(WHITE)) {
                neighbour.setDistance(neighbour.getDistance() + 1);
                neighbour.setPredecessor(item);
                neighbour.setColor(GRAY);
                queue.enqueue(neighbour);  // 当前节点入队列
            }
        }
        item.setColor(BLACK);
    }
}
```



## 深度优先搜索

### 概念

深度优先搜索是沿着树的单支尽量深入向下搜索，如果到无法继续的程度还未找到问题解，就回溯上一层再搜索下一分支。



### 骑士周游问题

骑士周游问题是一种特殊的对图进行深度优先搜索，其目的是建立一个没有分支的最深的深度优先树，表现为一条线性的包含所有节点的退化树。



如果沿着单个分支深入搜索到无法继续时（所有合法移动都已经被走过），路径长度还没有达到预定值（如果是 8×8 的棋盘，那么要走63步），那么就清除颜色标记，返回到上一层，换一个分支继续深入搜索。

如果没有一条有效路径，最后所有的节点都会恢复成白色，同时栈空。



## Dijkstra算法

解决带权最短路径问题的经典算法是以发明者命名的 "Dijkstra算法"

这是一个迭代算法，计算出从一个顶点到其余所有顶点的最短路径，很接近于广度优先搜索算法

