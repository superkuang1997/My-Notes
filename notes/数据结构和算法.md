

# 数据结构🐿

数据结构是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成。



## 数据的存储结构

数据的存储结构主要分为两类：

- 顺序结构

  数组是连续存储的，可以随机访问，通过索引快速找到对应元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 $O(N)$；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 $O(N)$ 。

- 链式结构

  链表是靠指针指向下一个元素的位置，所以不存在数组的扩容问题；如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度 $O(1)$ 。但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。



## 数据的逻辑结构

数据的逻辑结构主要分为四类：

- 集合结构
- 线性结构
- 树形结构
- 图形结构





## 大O表示法

n表示问题的规模，T(n) 的精确值并不重要，重要的是 T(n) 中起决定性作用的主导部分

例如 T(n) = 5n<sup>2</sup>+27n+100 ，时间复杂度为 O(n<sup>2</sup>)



## 复杂度计算







# 线性结构🐿

## 概念

线性结构是一种有序数据项的集合，除了第一个没有前驱，最后一个没有后继以外，每个数据项都有唯一的前驱和后继。线性是指的逻辑上的线性，即只要数据的保存满足了一对一关系，除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接没有例外；

不同线性结构的关键区别在于数据项增减的方式。

线性表分为顺序存储和链式存储两种方式。

- 对于顺序存储，存储结构为顺序表；

- 对于链式存储，存储结构为单链表、双链表、循环链表、静态链表等。

以下结构的共同点在于数据项之间只存在先后的次序关系，不同点在于数据的增减方式。



## 顺序存储

顺序表，使用数组实现，用一段内存上连续的存储单元依次存储线性表的数据元素。数组大小有两种方式指定，一是静态分配，二是动态扩展。

时间性能：查找 O(1) 、插入和删除 O(n)

空间性能：需要预分配存储空间，分大了浪费，小了容易发生溢出



## 链式存储

链表的定义是递归的，它或者为空，或指向另一个节点 node 的引用，这个节点含有下一个节点的引用。

与顺序存储相比，允许存储空间不连续，插入、删除元素不需要移动大量元素，只需要修改指针即可，但查找某个元素，只能从头遍历整个链表。

时间性能：查找 O(n) 、插入和删除 O(1)

空间性能：不需要分配存储空间，只要有就可以分配，元素个数不受限制



# 数组🐿

## 数组的概念

数组分配的内存空间是连续的，且内存大小一经确定之后便无法再更改。

优点：支持随机访问，查找效率高

缺点：增删效率低，扩容数组必须拷贝原数组到新数组



# 链表🐿

## 链表的概念

链表分配的内存空间不需要连续，每个数据都存储了下一个链表的地址，从而使离散的内存空间联系在一起。

优点：增删效率高，无需考虑扩容缩容

缺点：不支持随机访问，查找效率低



## 快慢指针

链表长度为偶数：slow -> 中间靠后的一个，fast  -> null

链表长度为奇数：slow -> 中间，fast -> 最后一个节点

```java
ListNode slow, fast;
slow = fast = head;
while (fast != null && fast.next != null) {
    slow = slow.next;
    fast = fast.next.next;
}
```





链表长度为偶数（比上面少跑一次）：slow -> 中间靠前的一个，fast  -> 尾结点前一个

链表长度为奇数：slow -> 中间，fast -> 最后一个节点

```java
ListNode slow, fast;
slow = fast = head;
while (fast.next != null && fast.next.nextt != null) {
    slow = slow.next;
    fast = fast.next.next;
}
```









# 栈🐿

## 栈的概念

栈是一种有次序的数据项集合，在栈中，数据项的加入和移除都仅发生在同一端。栈的一端叫栈顶，另一端叫栈底，距离栈底越近的数据项，留在栈中的时间就越长而最新加入栈的数据项会被最先移除，这种次序通常称为 "后进先出"。



## 栈的实现





## 栈的应用





# 队列🐿

## 队列的概念

队列是一种有次序的数据集合，其特征是新数据项的添加总发生在队尾，而现存数据项的移除总发生在队首，这种次序通常称为 “先进先出” 。



## 队列的实现

```java
public interface Queue<E> extends Collection<E> {

    boolean add(E e);  // 如果超出队列限制，会抛出异常

    boolean offer(E e);  // 如果超出队列限制，不会抛出异常而是返回false

    E remove(); // 移除队首的元素，如果队列为空会抛出异常

    E poll();  // 移除队首的元素，如果队列为空不会抛出异常

    E element();  // 查看队首的元素，如果队列为空会抛出异常

    E peek();  // 查看队首的元素，如果队列为空不会抛出异常
}
```





## 双端队列

双端队列 Deque 是一种有次序的数据集，跟队列相似，其两端可以称作队首与队尾，但 Deque 中数据项既可以从队首加入，也可以从队尾加入，同时数据项也可以从两端移除。

某种意义上说，双端队列集成了栈和队列的能力。



## 双端队列的实现

以下是Java中对Deque的实现

```java
public interface Deque<E> extends Queue<E> {

    void addFirst(E e);

    void addLast(E e);

    boolean offerFirst(E e);

    boolean offerLast(E e);

    E removeFirst();

    E removeLast();

    E pollFirst();

    E pollLast();

    E getFirst();

    E getLast();

    E peekFirst();

    E peekLast();

    boolean removeFirstOccurrence(Object o);

    boolean removeLastOccurrence(Object o);

    // *** Queue methods ***

    boolean add(E e);

    boolean offer(E e);

    E remove();

    E poll();

    E element();

    E peek();


    // *** Stack methods ***

    void push(E e);

    E pop();


    // *** Collection methods ***

    boolean remove(Object o);

    boolean contains(Object o);

    public int size();

    Iterator<E> iterator();

    Iterator<E> descendingIterator();

}

```





# 递归🐿

## 递归三要素

1. 递归函数的作用是什么？ 首先要明确递归函数的功能
2. 递归停止的条件是什么？ 当参数为某个值时，递归结束
3. 从某层到下一层的关系是什么？ 即如何缩小问题的规模，如何处理递归层级之间的关系



## 递归的关键

明确递归函数的「定义」是什么，然后相信这个定义，利用这个定义推导最终结果，绝不要跳入递归的细节。

树的递归算法

### 自顶而下递归

先搞清楚当前 root 节点该做什么，然后根据函数定义递归调用子节点，递归调用会让子节点做相同的事情。



### 自底而上递归

递归的过程：入栈 -> 入栈 -> 到达递归停止条件 -> 出栈 -> 出栈

要站在最后一次出栈的角度思考，要想着之前的 n 步递归已经完成了，再次基础上确定递归函数的要做的事情，不要陷入递归的细节。



## 分治策略

解决分治问题的时候，思路就是想办法把问题的规模减小，有时候减小一个，有时候减小一半，然后将每个小问题的解以及当前的情况组合起来得出最终的结果。

没有子问题重复出现，这是动态规划和分治的区别。



## 贪心策略

1. 关于最优子结构

- 贪心：每一步的最优解一定包含上一步的最优解，上一步之前的最优解无需记录

- 动态规划：全局最优解中一定包含某个局部最优解，但不一定包含上一步的局部最优解，因此需要记录之前的所有的局部最优解

2. 结果正确性

- 贪心不能保证求得的最后解是最佳的，复杂度低
- 动态规划本质是穷举法，可以保证结果是最佳的，复杂度高





# 查找🐿

## 顺序查找

时间复杂度：$O(n)$



## 二分查找

二分查找的前提条件：数据集有序

二分查找的时间复杂度： $O(log_2n)$

1. `while (i <= j)` 循环

   ```java
   public int search(int[] nums, int target) {
       int lo = 0, hi = nums.length - 1, mid = 0;
       while (lo <= hi) {
           mid = lo + ((hi - lo) >> 1);
           if (nums[mid] == target) {
               return mid;
           }
           if (nums[mid] < target) {
               lo = mid + 1;
           } 
           else {
               hi = mid - 1;
           }
       }
       return -1;
   }
   ```



2. `while (i < j) ` 循环

   ```
   
   ```

   



要注意判断条件

- 如果是小于等于，即 `lo <= hi` ，表示：在区间只有 1 个元素的时候，依然需要进行相关逻辑的判断。迭代到最后一定有 lo == hi == mid，那么需要一个出口才能结束循环。

- 如果没有等于号，即 `lo < hi`，那么迭代到 lo == hi 就不会再进入下一次循环了，即退出循环时一定有  lo == hi 成立，好处是不需要判断到底是返回 lo 还是返回 hi



### 复杂度分析

第一次查询后，剩余查询数为 $ N/2$

第二次查询后，剩余查询数为 $N/2^2$

第三次查询后，剩余查询数为 $N/2^3$

第四次查询后，剩余查询数为 $N/2^4$

假设第 k 次查询后找到 target，剩余查询时为 1，$N/2^k = 1$ ，则有 $ k = log_2n$





## 中值的确定

如果循环条件是 `while (i < j)` ，那么迭代过程中必须是 `i = m / j = m - 1` 或者 `i = m + 1 / j = m`

-  `i = m / j = m - 1 ` ：向上取整，`m = i + (j - i + 1) / 2`

-  `i = m + 1 / j = m ` ：向下取整，`m = i + (j - i) / 2`



例如，i = 1，j = 2，此处如果向下取整，则 m = 1 = i ，如果走的是 i = m ，则死循环，必须是 i = m + 1 才能缩小范围







# 排序🐿

<img src="http://store.secretcamp.cn/uPic/image-20210314201740375202103142017401615724260SGMTKgSGMTKg.png" alt="image-20210314201740375" style="zoom: 50%;" />



## 排序算法的稳定性

假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中， r[i] = r[j] ，且 r[i] 在 r[j] 之前，而在排序后的序列中，r[i] 仍在 r[j] 之前，则称这种排序算法是稳定的；否则称为不稳定的。



## 冒泡排序

冒泡排序的算法思路在于对无序表进行多趟比较交换

- 每趟包括了多次两两相邻比较，并将逆序的数据项互换位置，最终能将本趟的最大项就位

- 经过 n-1 趟比较交换，实现整表排序
- 第一趟需要比较 n-1 次，第二趟需要比较 n-2 次，以此类推并减少到 1

- 每趟的过程类似于 “气泡” 在水中不断上浮到水面的经过

<img src="http://store.secretcamp.cn/uPic/image-20201225092432920202012250924331608859473fQFkULfQFkUL.png" alt="image-20201225092432920" style="zoom: 40%;" />

算法分析：

- 比较次数是 1 ~ n-1 的累加 $\frac{1}{2}n^2-\frac{1}{2}n$，时间复杂度是 $O(n^2)$
- 每次交换包括三次赋值，次数为 $\frac{3}{2}n^2-\frac{3}{2}n$，时间复杂度是 $O(n^2)$
- 最好情况下，数组是顺序，只需要比较不需要交换，时间复杂度是 $O(n^2)$
- 最坏情况下，数组是逆序，每次都要比较和交换，时间复杂度是 $O(n^2)$
- 平均时间复杂度为 $O(n^2)$，无序表初始数据项的排列状况对冒泡排序的时间复杂度没有影响



```java
public static void bubbleSort(int[] array) {
    for (int passnum = array.length - 1; passnum > 0; passnum--) {
        for (int i = 0; i < passnum; i++) {
            int temp;
            if (array[i] > array[i + 1]) {
                temp = array[i];
                array[i] = array[i + 1];
                array[i + 1] = temp;
            }
        }
    }
}
```



## 选择排序

选择排序对冒泡排序进行了改进，保留了其基本的多趟比对思路，每趟都使当前最大项就位。

但选择排序对交换进行了削减，相比起冒泡排序进行多次交换， 每趟仅进行 1 次交换，记录最大项的所在位置，最后再跟本趟最后一项元素交换。

算法分析：

- 比对次数不变，还是 $O(n^2)$
- 交换次数则减少为 $O(n)$

<img src="http://store.secretcamp.cn/uPic/image-20201225095840022202012250958401608861520ERg7P2ERg7P2.png" alt="image-20201225095840022" style="zoom: 50%;" />

```java
public static void selectSort(int[] array) {
    int passnum = array.length - 1;
    while (passnum > 0) {
        int indexOfMax = 0;
        for (int i = 1; i <= passnum; i++) {
            if (array[i] > array[indexOfMax]) {
                indexOfMax = i;
            }
        }
        int temp = array[indexOfMax];
        array[indexOfMax] = array[passnum];
        array[passnum] = temp;
        passnum--;
    }
}
```



## 插入排序

插入排序维持一个已排好序的子列表，其位置始终在列表的前部，然后逐步扩大这个子列表直到全表

算法分析：

- 最差情况下，每趟都与子列表中所有项进行比对，时间复杂度为 $O(n^2)$
- 最好情况下，列表已经排好序，每趟仅需1次比对，总次数是 $O(n)$



<img src="http://store.secretcamp.cn/uPic/image-20201225102452760202012251024521608863092BlVcjRBlVcjR.png" alt="image-20201225102452760" style="zoom:50%;" />





```java
public static void insertSort(int[] array) {
    for (int i = 1; i < array.length; i++) {
        int position = i;
        int currentValue = array[position];
        while (position > 0 && array[position - 1] > currentValue) {
            array[position] = array[position - 1];
            position--;
        }
        array[position] = currentValue;
    }
}
```





## 希尔排序

希尔排序是对插入排序的改进

算法分析：

- 根据间隔将列表划分为多个子列表，分别对每个子列表带使用带间隔的插入排序
- 子列表的间隔 n/2，n/4，n/8……

- 对子列表进行排序之后，列表整体已经接近有序，但不是完全有序，最后一次，使用标准的插入排序

- 时间复杂度最好为 $O(n)$ ，最差为 $O(n^2)$ ，平均为$O(n^{3/2})$

<img src="http://store.secretcamp.cn/uPic/image-202012251624527412020122516245216088846928tNJTC8tNJTC.png" alt="image-20201225162452741" style="zoom:50%;" />

```java
// 希尔排序
public static void shellSort(int[] list) {
    int subListCount = list.length / 2;
    while (subListCount > 0) {
        for (int start = 0; start < subListCount; start++) {
            insertSortWithGap(list, start, subListCount);
        }
        subListCount /= 2;
    }
}

// 带间隔的插入排序
public static void insertSortWithGap(int[] list, int start, int gap) {
    for (int i = start; i < list.length; i += gap) {
        int position = i;
        int currentValue = list[position];
        while (position > start && list[position - gap] > currentValue]) {
            list[position] = list[position - gap];
            position -= gap;
        }
        list[position] = currentValue;
    }
}
```



## 归并排序

1. 递归的基本结束条件：数据表仅有 1 个数据项，自然是排好序的；

2. 缩小规模：将数据表分裂为相等的两半，规模减 为原来的二分之一；

3. 调用自身：将两半分别调用自身排序，然后将分 别排好序的两半进行归并，得到排好序的数据表

<img src="http://store.secretcamp.cn/uPic/image-20201225163107957202012251631081608885068fuZOr2fuZOr2.png" alt="image-20201225163107957" style="zoom:50%;" />

<img src="http://store.secretcamp.cn/uPic/image-20201225163127228202012251631271608885087x332vex332ve.png" alt="image-20201225163127228" style="zoom:53%;" />

算法分析：

- 归并排序是递归算法，思路是将数据表持续分裂为两半，对两半分别进行归并排序

- 分裂的过程，时间复杂度为 $O(log_2n)$
- 归并的过程，相对于分裂的每个部分，所有数据项都会被比较和放置一次，其时间复杂度是 $O(n)$
- 总体时间复杂度为 $O(nlog_2n)$

- 归并排序算法使用了额外一倍的存储空间用于归并



```java
public static void mergeSort(int[] list) {
    // 递归结束条件 list.length == 1
    if (list.length == 1) {
        return;
    }

    int mid = list.length / 2;
    // 分裂，并调用自身
    int[] leftBranch = Arrays.copyOfRange(list, 0, mid);
    int[] rightBranch = Arrays.copyOfRange(list, mid, list.length);
    mergeSort(leftBranch);
    mergeSort(rightBranch);

    // 左分支计数器
    int i = 0;
    // 右分支计数器
    int j = 0;
    // 整体归并计数器
    int k = 0;

    // 归并
    while (i < leftBranch.length && j < rightBranch.length) {
        if (leftBranch[i] < rightBranch[j]) {
            list[k] = leftBranch[i];
            i++;
        } else {
            list[k] = rightBranch[j];
            j++;
        }
        k++;
    }

    // 处理余项
    while (i < leftBranch.length) {
        list[k] = leftBranch[i];
        i++;
        k++;
    }
    while (j < rightBranch.length) {
        list[k] = rightBranch[j];
        j++;
        k++;
    }

}
```



## 快速排序

快速排序的思路是依据一个 “中值” 数据项来把数据表分为两半：小于中值的一半和大于中值的一半，然后每部分分别进行快速排序。

- 首先设定列表中的第一个数为中值
- 设置左右标，左标向右移动，右标向左移动
  - 左标一直向右移动，碰到比中值大的就停止
  - 右标一直向左移动，碰到比中值小的就停止
  - 将左右标所指的数据项交换
- 继续以上步骤，直到左标移动到右标右侧，停止移动
- 此时右标所处应该是中值的新位置，将右标与中值位置交换
- 分裂完成，列表的左半部分比中值小，右半部分比中值大
- 对左半部和右半部分别递归调用快速排序

<img src="http://store.secretcamp.cn/uPic/image-20201225174318008202012251743181608889398sHLm58sHLm58.png" alt="image-20201225174318008" style="zoom:50%;" />

<img src="http://store.secretcamp.cn/uPic/image-20201225174414617202012251744141608889454dxmQEJdxmQEJ.png" alt="image-20201225174414617" style="zoom:47%;" />



算法分析：

- 分裂
  - 如果分裂总能将数据表分为相等两部分，则为 $O(log_2n)$ 
  - 如果中值所在分裂点过于偏离中部，例如某列表已经是正序排列，那么左标不移动，但右标每次都会移动到左标左侧，交换后中值的位置不变，仍处于最左侧，那么分裂的时间复杂度为 $O(n)$

- 移动： 移动时需要将每项都与中值进行比对，为 $O(n)$

总时间复杂度：最优为 $O(nlog_2n)$ ，最差为 $O(n^2)$



稳定性分析：

快速排序是不稳定的，在中值元素和右标交换的时候，很有可能把前面的元素的稳定性打乱。



```java
public static void quickSort(int[] nums) {
    partition(nums, 0, nums.length - 1);
}

public static void partition(int[] nums, int first, int last) {
    int pivot = first;
    int left = first + 1;
    int right = last;
    if (first < last) {
        while (true) {
            while (left < last && nums[left] <= nums[pivot]) left++;
            while (right > first && nums[right] >= nums[pivot]) right--;
            if (left >= right) {
                swap(nums, pivot, right);
                break;
            } else swap(nums, left, right);
        }
        partition(nums, first, right - 1);
        partition(nums, right + 1, last);
    }
}

private static void swap(int[] nums, int a, int b) {
    int tmp = nums[a];
    nums[a] = nums[b];
    nums[b] = tmp;
}
```



```java
public static void quicksort(int[] nums) {
    partition(nums, 0, nums.length - 1);
}

public static void partition(int[] nums, int lo, int hi) {
    if (lo >= hi) return;
    int mid = nums[lo];
    int i = lo, j = hi + 1;
    while (true) {
        while (++i < hi && nums[i] < mid);
        while (--j > lo && nums[j] > mid);
        if (i >= j) {
            break;
        }
        swap(nums, i, j);
    }
    swap(nums, lo, j);
    partition(nums, lo, j - 1);
    partition(nums, j + 1, hi);

}

private static void swap(int[] nums, int i, int j) {
    int tmp = nums[i];
    nums[i] = nums[j];
    nums[j] = tmp;
}
```



## 堆排序

算法分析：

- 时间复杂度： $O(log_2n)$ 

稳定性分析：堆排序是不稳定的



- 使用额外空间：创建一个新数组，直接从堆顶出堆即可。

- 如果不用额外的空间：将堆顶元素 swap 到堆尾，同时减少堆的 size ，重新下沉被 swap 到堆顶的元素

  - 小根堆堆排序之后的结果是逆序

  - 大根堆排序之后的结果是顺序

```java
package base.structure.heap;

import java.util.Arrays;

/**
 * 最小堆的实现
 */
public class MinHeap {

    /**
     * 将所有元素以完全二叉树的形式存入数组
     */
    private final int[] heap;

    /**
     * 堆中元素的个数
     */
    private int curSize;

    public MinHeap(int curSize) {
        heap = new int[curSize];
    }

    public MinHeap(int[] nums, int maxSize) {
        heap = new int[Math.max(maxSize, nums.length)];
        System.arraycopy(nums, 0, heap, 0, nums.length);
        curSize = heap.length;
        // 从最后一个节点的父节点开始下沉，叶节点无需下沉
        int pos = (curSize - 2) / 2;
        while (pos >= 0) {
            shiftDown(pos);
            pos--;
        }
    }


    /**
     * 从最后一个节点上浮 插入新元素后，新元素处于数组最后的位置，即索引为 size - 1
     *
     * @param i 开始上浮的索引
     */
    private void shiftUp(int i) {
        //  如果存在父节点
        while ((i - 1) / 2 >= 0 && i != 0) {
            if (heap[i] < heap[(i - 1) / 2]) {
                swap(heap, i, (i - 1) / 2);
            }
            else {
                break;
            }
            i = (i - 1) / 2;
        }
    }

    /**
     * 从某个节点下沉
     *
     * @param i 节点索引
     */
    private void shiftDown(int i) {
        // 当前节点的左子节点索引小于等于最后一个节点索引，说明还有下沉的空间
        while (2 * i + 1 <= curSize - 1) {
            int smallerChild = getSmallerChild(i);
            if (heap[i] > heap[smallerChild]) {
                swap(heap, i, smallerChild);
            }
            i = smallerChild;
        }
    }

    public void insert(int num) {
        if (curSize < heap.length) {
            heap[curSize++] = num;
            shiftUp(0);
        }
    }

    public void del() {
        if (curSize > 0) {
            // 删除堆顶元素，并将堆尾元素回填到堆顶
            heap[0] = heap[curSize - 1];
            curSize--;
            // 下沉
            shiftDown(0);

        }
    }


    /**
     * 返回较小子节点的索引
     *
     * @param i 父节点的索引
     * @return 较小子节点的索引
     */
    private int getSmallerChild(int i) {
        // 如果没有右子节点，则直接返回左子节点。
        if (2 * i + 2 > curSize - 1) {
            return 2 * i + 1;
        }
        // 如果都有，则返回其中较小的一个
        else {
            return heap[2 * i + 1] < heap[2 * i + 2] ? 2 * i + 1 : 2 * i + 2;
        }
    }
    /**
     * 小根堆 堆排序之后的结果是逆序
     */
    public void heapSort() {
        int size = curSize;
        for (int i = 0; i < size; i++) {
            swap(heap, 0, curSize - 1);
            curSize--;
            shiftDown(0);
        }
        System.out.println(Arrays.toString(heap));
    }

    private void swap(int[] heap, int i, int j) {
        int tmp = heap[i];
        heap[i] = heap[j];
        heap[j] = tmp;
    }

    @Override
    public String toString() {
        return "MinHeap{" +
                "heap=" + Arrays.toString(Arrays.copyOf(heap, curSize)) +
                ", curSize=" + curSize +
                '}';
    }
}
```









# 位运算🐿

## 按位与

奇数的最后一位一定是 1 ，偶数的最后一位一定是 0

奇数：num & 1 = 1 
偶数：num & 1 = 0 







## 按位或





## 按位异或

如果 a、b 两个值不相同，则异或结果为 1 。如果 a、b 两个值相同，异或结果为 0 。

异或的特点：

二进制：

- 0 ^ 任何数 ＝ 任何数
- 1 ^ 任何数 = 任何数取反
- XOR 运算满足交换律和结合律：a⊕b⊕a = (a⊕a)⊕b = 0⊕b = b

>  速记：男性和女性能生出孩子，否则就不行。

```
True  ⊕ False = True
False ⊕ True  = True
False ⊕ False = False
True  ⊕ True  = False
```

<img src="http://store.secretcamp.cn/uPic/image-20210810123449671202108101234501628570090HtnYJ4HtnYJ4.png" alt="image-20210810123449671" style="zoom:40%;" />



十进制：

0 ^ 十进制数 = 这个十进制数本身



## 计算技巧

技巧一：

(n−1) ： 二进制数字 n 最右边的 1 变成 0 ，此 1 右边的 0 都变成 1 。

n \& (n - 1)： 二进制数字 n 最右边的 1 变成 0 ，其余不变。 这个操作可以统计二进制中 1 的个数



技巧二：

高位 1 的二进制数减去低位 1 的二进制数 ，高位 1 和低位 1 之间的 0 都会变成 1

10000 - 00010 = 01110

 想知道二进制可以拆成几个相减的组合，只需要统计有几个连续的 1 串就可以了

111 -> 1/1/1、1/11、11/1



# 动态规划🐿

## 动态规划的类型

动态规划有两种求解形式：

- 自顶向下：也就是记忆化递归，求解过程会遇到重复子问题，所以需要记录每一个子问题的结果；

- 自底向上：通过发现一个问题最开始的样子，通过「递推」一步一步求得原始问题的解。



## 要义

解决动态规划问题的核心：找出子问题及其子问题与原问题的关系

1. 明确 base case

2. 明确「状态」

3. 明确「选择」

4. 定义 dp 数组/函数的含义。

状态：会变化的就是状态

选择：导致状态变化的动作就是选择

```python
# 初始化 base case
dp[0][0][...] = base
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```





自顶向下递归 + 备忘录

自底向上的动态规划 + DP Table



## 贪心算法

贪心选择特质是指每一步都做出一个局部最优的选择，最终的结果就是全局最优。

这是一种特殊性质，其实只有一部分问题拥有这个性质。

与动态规划的联系：

- 都是分解成子问题来求解，都需要具有最优子结构

- 所有的贪心问题都可以用动态规划来求解，可以这么说，贪心算法是动态规划的特例。

与动态规划的区别：

- 贪心：每一步的最优解一定包含上一步的最优解，上一步之前的最优解则不作保留；

- 动态规划：全局最优解中一定包含某个局部最优解，但不一定包含前一个局部最优解，因此需要记录之前的所有的局部最优解 

简单的说，假如要求第十步的最优解，那么第十步的最优解肯定与第九步的最优解有关，而第九步的最优解肯定与第八步的最优解有关。可以这么理解，贪心算法第十步的最优解得把前面九步的最优解都用上了，但是动态规划你需要求第十步的最优解，这个最优解可能只与第八步，第三步，第一步有关，与第九步没有关系。

我们为什么选择第八步而不选择第九步呢？是因为我们在计算第十步的最优解的时候其实把1-9步的组合的情况都计算了，选择了其中最优的解，也就是第八步的解，其实第十步解的构成与第九步没有关系，动态规划相当于穷举了1-9步最优情况下的组合，选了其中最优的作为第十步的最优解，而贪心算法第十步的最优解肯定是由第九步构成的。



## 组合问题

根据循环不同，答案可能是排列数、也可能是组合数

排列数：[1,2] 和 [2,1] 不是同一个结果

组合数： [1,2] 和 [2,1]  是同一个结果

一般该问题下有两种状态，一是目的的状态，而是手段的状态

比如换零钱中，目标金额就是目的的状态，零钱的种类是手段的状态

先遍历目的的状态，后遍历手段的状态 -> 排列数

先遍历手段的状态，后遍历目的的状态 -> 组合数





# Hash🐿

## Hash的概念

Hash也称散列，基本原理就是把任意长度的输入，通过映射变成固定长度的输出。这个映射的规则就是对应的 hash 算法，而原始数据映射后的二进制串就是哈希值。



hash的特点：

1. 从 hash 值不可以反向推导出原始的数据
2. 输入数据的微小变化会得到完全不同的 hash 值，相同的数据会得到相同的值 
3. 哈希算法的执行效率要高效，长的文本也能快速地计算出哈希值 
4. hash 算法的散列冲突概率较小

> 由于 hash 的原理是将入空间的值映射成 hash 空间内，而 hash 值的空间远小于输入的空间根据抽屉原理，一定会存在不同的输入被映射成相同输出的情况。





## hash表的实现

- 首先开辟一定长度的，具有连续物理地址的桶数组；

- 当我们插入一个新的键时，哈希函数将决定该键应该分配到哪个桶中，并将该键存储在相应的桶中；

- 当我们想要搜索一个键时，哈希表将使用哈希函数来找到对应的桶，并在该桶中进行搜索。



## hash冲突的解决方法

### 开放定址





### 链地址法







# 二叉堆🐿

## 优先队列

队列是遵循先进先出（First-In-First-Out）模式的，但有些时候需要在队列中基于优先级处理对象，于是便有了优先队列（PriorityQueue），优先队列实际上是一个二叉堆。



## 二叉堆的概念

堆又指二叉堆，本质上是一种完全二叉树，它分为两个类型：

- 最小堆（小根堆）：任何一个父节点的值，都小于等于它左右孩子节点的值。
- 最大堆（大根堆）：任何一个父节点的值，都大于等于它左右孩子节点的值。

完全二叉树：若设二叉树的深度为 k ，除第 k 层外，其它各层（1～k-1）的结点数都达到最大个数，第 k 层所有的结点都连续集中在最左边。

<img src="http://store.secretcamp.cn/uPic/image-20210109090650538202101090906511610154411kNu9jokNu9jo.png" alt="image-20210109090650538" style="zoom: 33%;" />



二叉堆的根节点叫做 “堆顶”，符合 “堆” 性质的二叉树，其中任何一条路径，均是一个已排序数列

> 这里的 "堆" 是指数据结构中的堆，而不是内存模型中的堆



## 二叉堆的实现

完全二叉树由于其特殊性，可以用非嵌套 列表，以简单的方式实现。

二叉堆一般都通过 “数组” 来实现。数组实现的二叉堆，父节点和子节点的位置存在一定的关系。有时候，我们将 “二叉堆的第一个元素” 放在数组索引为 0 的位置，有时候放在 1 的位置，它们的本质一样，只是实现上稍微有一些区别。

假设“第一个元素”在数组中的索引为 0 的话，则父节点和子节点的位置关系如下：

- 索引为 i 的左孩子的索引是 $2*i+1$

- 索引为 i 的右孩子的索引是 $2*i+2$

- 索引为 i 的父结点的索引是 $floor((i-1)/2);$

 

假设“第一个元素”在数组中的索引为 1 的话，则父节点和子节点的位置关系如下：

- 索引为 i 的左孩子的索引是 $2*i$
- 索引为 i 的右孩子的索引是 $2*i+1$
- 索引为 i 的父结点的索引是 $floor(i/2)$



<img src="http://store.secretcamp.cn/uPic/image-20210710175845716202107101758461625911126u87HCCu87HCC.png" alt="image-20210710175845716" style="zoom:50%;" />



如果向二叉堆中添加新的节点，必须要满足以下要求：

- 保持完全二叉树的性质：新节点必须被添加到数组的末尾
- 保持堆结构的性质：从堆顶出发的任意路径上的所有节点都是有序的



### 上浮

新节点加在列表末尾，显然无法保持堆次序，所以需要将新节点沿着路径来 "上浮" 到其正确位置

“上浮” 路径的选择：搜索当前节点的父节点，如果父节点的值大于当前节点，则交换，一直上浮到根节点。



### 下沉

删除数组中的节点，显然破坏了树的结构，为了保持树的结构，需要用一个节点来替换到被删除的位置。

为了保持完全二叉树的性质，显然用最后一个叶节点替换是最好的选择，所以将最后一个节点移动到被删除的位置，之后，为了保持堆次序，需要将新节点沿着路径 "下沉" 到其正确位置。

“下沉” 路径的选择：下沉节点如果大于子节点，那么选择较小的子节点交换下沉，一直下沉到叶节点。



### 实现

```java
package base.structure.heap;

import java.util.Arrays;

/**
 * @author by yorua
 * @description 小根堆的实现
 * @date 2021/7/10 17:53
 */
public class MinHeap {

    /**
     * 将所有元素以完全二叉树的形式存入数组
     */
    private final int[] heap;

    /**
     * 堆中元素的个数
     */
    private int curSize;

    public MinHeap(int curSize) {
        heap = new int[curSize];
    }

    public MinHeap(int[] nums, int maxSize) {
        heap = new int[Math.max(maxSize, nums.length)];
        System.arraycopy(nums, 0, heap, 0, nums.length);
        curSize = heap.length;
        // 从最后一个节点的父节点开始下沉，叶节点无需下沉
        int pos = (curSize - 2) / 2;
        while (pos >= 0) {
            shiftDown(pos);
            pos--;
        }
    }


    /**
     * 从最后一个节点上浮 插入新元素后，新元素处于数组最后的位置，即索引为 size - 1
     *
     * @param i 开始上浮的索引
     */
    private void shiftUp(int i) {
        //  如果存在父节点
        while ((i - 1) / 2 >= 0 && i != 0) {
            if (heap[i] < heap[(i - 1) / 2]) {
                swap(heap, i, (i - 1) / 2);
            }
            else {
                break;
            }
            i = (i - 1) / 2;
        }
    }

    /**
     * 从某个节点下沉
     *
     * @param i 节点索引
     */
    private void shiftDown(int i) {
        // 当前节点的左子节点索引小于等于最后一个节点索引，说明还有下沉的空间
        while (2 * i + 1 <= curSize - 1) {
            int smallerChild = getSmallerChild(i);
            if (heap[i] > heap[smallerChild]) {
                swap(heap, i, smallerChild);
            }
            i = smallerChild;
        }
    }

    public void insert(int num) {
        if (curSize < heap.length) {
            heap[curSize++] = num;
            shiftUp(0);
        }
    }

    public void del() {
        if (curSize > 0) {
            // 删除堆顶元素，并将堆尾元素回填到堆顶
            heap[0] = heap[curSize - 1];
            curSize--;
            // 下沉
            shiftDown(0);

        }
    }


    /**
     * 返回较小子节点的索引
     *
     * @param i 父节点的索引
     * @return 较小子节点的索引
     */
    private int getSmallerChild(int i) {
        // 如果没有右子节点，则直接返回左子节点。
        if (2 * i + 2 > curSize - 1) {
            return 2 * i + 1;
        }
        // 如果都有，则返回其中较小的一个
        else {
            return heap[2 * i + 1] < heap[2 * i + 2] ? 2 * i + 1 : 2 * i + 2;
        }
    }
    /**
     * 小根堆 堆排序之后的结果是逆序
     */
    public void heapSort() {
        int size = curSize;
        for (int i = 0; i < size; i++) {
            swap(heap, 0, curSize - 1);
            curSize--;
            shiftDown(0);
        }
        System.out.println(Arrays.toString(heap));
    }

    private void swap(int[] heap, int i, int j) {
        int tmp = heap[i];
        heap[i] = heap[j];
        heap[j] = tmp;
    }

    @Override
    public String toString() {
        return "MinHeap{" +
                "heap=" + Arrays.toString(Arrays.copyOf(heap, curSize)) +
                ", curSize=" + curSize +
                '}';
    }

}

```









# 二叉树🐿

## 树的概念

树是由若干节点（node）， 以及由节点间两两连接的边（edge）组成，并有如下性质：

- 其中一个节点被设定为根

- 每个节点n（除根节点），都连接一条来自节点p的边，p是n的父节点；

- 每个节点从根开始的路径是唯一的 

- 如果每个节点最多有两个子节点， 这样的树称为 "二叉树"



## 二叉树

一棵二叉树是结点的一个有限集合，该集合或者为空，或者是由一个根节点加上两棵分别称为左子树和右子树的二叉树组成。

- 二叉树的每个结点最多有两棵子树，即二叉树不存在度大于2的结点

- 二叉树的子树有左右之分，其子树的次序不能颠倒







## 遍历树



<img src="http://store.secretcamp.cn/uPic/%E4%BA%8C%E5%8F%89%E6%A0%91202012271057491609037869IV14ujIV14uj.png" alt="二叉树" style="zoom:50%;" />

### 前序遍历

"中 -> 左 -> 右"

1 -> 2 -> 4 -> 8 -> 9 -> 5 -> 3 -> 6 -> 7

```java
public static void preOrder(BinaryTree tree) {
    if (tree != null) {
        System.out.println(tree.getRoot());
        preOrder(tree.getLeftBranch());
        preOrder(tree.getRightBranch());
    }
}
```



### 中序遍历

"左 -> 中 -> 右"

8 -> 4 -> 9 -> 2 -> 5 -> 1 -> 6 -> 3 -> 7

```java
public static void inOrder(BinaryTree tree) {
    if (tree != null) {
        preOrder(tree.getLeftBranch());
        System.out.println(tree.getRoot());
        preOrder(tree.getRightBranch());
    }
}
```



### 后续遍历

"左 -> 右 -> 中"

8 -> 9 -> 4 -> 5 -> 2 -> 6 -> 7 -> 3 -> 1

```java
public static void postOrder(BinaryTree tree) {
    if (tree != null) {
        preOrder(tree.getLeftBranch());
        preOrder(tree.getRightBranch());
        System.out.println(tree.getRoot());
    }
}
```



后序遍历的倒序为 "中 -> 右 -> 左"，是前序遍历 "中 -> 左 -> 右" 的镜像



## 二叉树的缺点

尽管二叉树的操作效率较高，但是也存在问题

- 由于构建二叉树时需要把数据从某个地方（数据库、文件等）加载到内存，如果节点少，那没什么问题，但如果有海量节点，在构建二叉树时，每个节点都会进行一次 I/O 操作，那么构建二叉树的速度就会很慢。
- 如果二叉树有海量节点，那么树的高度也特别高，当进行增加、删除、左旋、右旋节点等操作时，速度也会变慢。



## 多叉树的概念

二叉树中每个结点有一个数据项，最多有两个子节点，如果允许树的每个节点可以有两个以上的子节点，那么这个树就称为n阶的多叉树，或者称为n叉树。

- 多叉树每个节点有更多的数据项，那么相较于二叉树节点数量会变少。
- 多叉树每个节点可以有多个子节点，那么相较于二叉树高度也会降低。



## 完美二叉树

若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。（第 h 层可能包含 1~ 2^h 个节点。）



## 满二叉树

在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子节点都在同一层上





 





# 二叉搜索树🐿

## 二叉搜索树的概念

二叉搜索树（BST，binary search tree）是具有下列性质的二叉树：

- 若它的左子树不空，则左子树上所有结点的值均 小于 它的根节点的值；

- 若它的右子树上所有结点的值均 大于 它的根节点的值；

- 它的左、右子树也分别为二叉排序树。

对BST进行中序遍历，得到的结果是有序的。



## 二叉搜索树的实现

### 添加节点

1. 首先看bst是否为空，如果一个节点都没有，那么第一个节点将成为根节点root

2. bst不为空，则调用一个递归方法 put 来放置节点

   - 如果 key > currentNode，那么put到左子树

   - 如果 key < currentNode，那么put到右子树

### 查找节点

1. 首先看bst是否为空，如果为空则直接返回null

2. bst不为空，则调用一个递归方法 get 来查找节点

   - 如果 key = currentNode，则返回当前节点

   - 如果 key > currentNode，则对右子树调用get方法

   - 如果 key < currentNode，则对左子树调用get方法

3. 如果没有找到，则从栈底向栈顶返回null

### 删除节点

从bst中移除一个节点，还要求仍然保持bst的性质，分以下3种情形：

- 这个节点没有子节点 

- 这个节点有一个子节点 

- 这个节点有两个子节点

<img src="http://store.secretcamp.cn/uPic/image-202101061053198732021010610532016099016004wEFrU4wEFrU.png" alt="image-20210106105319873" style="zoom: 50%;" />





1）对于没有子节点的情形，最为简单，直接删除该节点即可。

2）对于只有一个子节点的情形，只需删除该节点，并处理好子节点与父节点的关系即可。

3）对于有两个子节点的情形，这时无法简单地将某个子节点上移替换被删节点，但可以找到另一个合适的节点来替换被删节点。

这个节点被称为 后继节点（successor）或者 前驱节点（predecessor），后继节点是其右子树中key最小的节点，即大于当前节点的所有节点中的最小值，前驱结点是当前节点左子树中key最大的节点，即小于当前节点的所有节点中的最大值。

以后继节点为例分析：

此时后继节点一定是叶节点或者仅有右子节点，因为如果后继节点有左子节点，那么它的左子节点才应该是后继节点。

<img src="http://store.secretcamp.cn/uPic/image-20210106110642846202101061106431609902403MG0c3zMG0c3z.png" alt="image-20210106110642846" style="zoom: 33%;" />





## 二叉搜索树的性能分析

二叉搜索树的性能决定因素在于树的高度，而其高度又受数据项插入顺序的影响。

- 如果 key 的列表是随机分布，那么大于和小于根节点key的节点大致相等，那么bst的高度就是 $log_2n$，这样的树就是平衡树，此时put方法的性能为 $O(log_2n)$

- 如果按照从小到大顺序插入的话，这时候put方法的性能为 $O(n)$，此时bst会退化成链表。









# AVL树🐿



## AVL树的概念

平衡二叉树（Self-balancing binary search tree）是基于二分法的策略提高数据的查找速度的二叉树的数据结构；

它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树，同时，平衡二叉树必定是二叉查找树。



AVL树是最先发明的自平衡二叉查找树，在AVL树中任何节点的两个子树的高度最大差别为1，增加和删除可能需要通过一次或多次旋转来重新平衡这个树。AVL树得名于发明者的名字缩写：G.M. Adelson-Velskii and E.M. Landis





## AVL树的实现

AVL树的实现中，需要对每个节点跟踪平衡因子（balance factor）

平衡因子是根据节点的左右子树的高度来定义的，确切地说，是左右子树高度差：

```
balanceFactor = height(leftSubTree) - height(rightSubTree)
```

- 平衡因子大于0，称为 "左重" left-heavy 
- 平衡因子小于0，称为 "右重" right-heavy 

- 平衡因子等于0，则称作平衡

如果一个二叉查找树中每个节点的平衡因子都在 [-1，0，1] 之间，则把这个二叉搜索树称为平衡树



AVL树与一般的二叉搜索树的区别，仅仅体现在添加节点中。在添加节点的操作中，要保持树中节点的平衡因子在 [-1，0，1] 之间。



### 右重左旋

右重 -> 为了减少右重，将右子节点B提升为子树的根 

左旋 -> 提升之前的右子节点B的key较大，所以提升后将旧根节点A设为新根节点的左子节点

如果左旋前的右子节点B存在左子节点D，那么该节点的值一定大于节点A，左旋后将D作为A的右子节点，注意不能将A作为D的左子节点。

<img src="http://store.secretcamp.cn/uPic/image-20201228173403691202012281734031609148043U0VwT0U0VwT0.png" alt="image-20201228173403691" style="zoom:40%;" />

<img src="http://store.secretcamp.cn/uPic/687474703a2f2f692e696d6775722e636f6d2f363877536c58392e6769662020122917054216092327424iwTfh4iwTfh.gif" style="zoom:150%;" />

### 左重右旋

左重 -> 为了减少左重，将左子节点提升为子树的根 

右旋 -> 提升之前的左子节点的key较小，所以提升后将旧根节点设为新根节点的右子节点

如果右旋前的左子节点B已经存在右子节点C，那么该节点的值一定小于节点A，所以右旋后将C作为A的左子节点

<img src="http://store.secretcamp.cn/uPic/image-20201228172424585202012281724241609147464WCou4IWCou4I.png" alt="image-20201228172424585" style="zoom:35%;" />

<img src="http://store.secretcamp.cn/uPic/687474703a2f2f692e696d6775722e636f6d2f446e6e4d4d75642e676966202012291707031609232823CfBMm2CfBMm2.gif" style="zoom:150%;" />

### 旋转的特殊情况

对以下 "右重" 二叉查找树进行左旋操作，仍然不能实现平衡，仅仅是从 "右重" 变成了 "左重"。

<img src="http://store.secretcamp.cn/uPic/image-202012281834188482020122818341916091516596F7z8y6F7z8y.png" alt="image-20201228183418848" style="zoom: 45%;" />



所以，在左旋转之前可以检查右子节点的平衡因子，如果右子节点 "左重" 的话，先对它进行右旋转，再对该子树的根节点实施原来的左旋转。

<img src="http://store.secretcamp.cn/uPic/image-20201228183633620202012281836331609151793HJFROBHJFROB.png" alt="image-20201228183633620" style="zoom:60%;" />

同理，对于 "左重" 二叉查找树，如果左子节点 "右重" 的话，先对它进行左旋转，再实施原来的右旋转。



### 平衡因子分析

<img src="http://store.secretcamp.cn/uPic/image-202012291505342892020122915053416092255341bCZ5Z1bCZ5Z.png" alt="image-20201229150534289" style="zoom:50%;" />

如果所示试一次左旋操作，在操作前后只有B、D的平衡因子发生了改变，A、C、E的平衡因子没有发生改变

现在想知道左旋前后节点B的平衡因子如何变化，分析如下：


$$
oldh_B = h_A - old^h_D = h_A - (1 + max(h_C, h_E))
$$

$$
newh_B = h_A - h_C
$$

$$
newh_B - oldh_B = 1 + max(h_C,h_E) - h_c = 1 + max(0, h_E-h_C) = 1 + max(0, -h_D)
$$

最后可以得到：
$$
newh_B  = oldh_B + 1 - min(0, h_D)
$$

设旧根节点为old，新根节点为new，经过同样的分析，有以下结论：

- 左旋old：$old = old + 1 - min(new,0)$

- 左旋new：$new = new + 1 - max(old，0)$

- 右旋old：$old = old - 1 + max(new,0)$

- 右旋new：$new = new - 1 + min(old,0)$





# 红黑树🐿

## AVL树的不足

红黑树属于平衡二叉树，但并不严格，是因为它不是严格控制左、右子树高度或节点数之差小于等于 1 。

AVL 树的要求子树的高度差不超过 1 ，所以在添加节点时经常需要进行旋转操作，这会消耗大量的性能，在实际环境下的应用不如红黑树。

具体分析：

红黑树为什么综合性主要是运用了节点的缓存，《算法》中提到，红黑树等价于 2-3 树。

其中二节点等价于普通平衡二叉树的节点，三节点本质上是非平衡性的缓存。

当需要再平衡（rebalance）时，增删操作时，二节点与三节点间的转化会吸收不平衡性，減少旋转次数，使再平衡尽快结束。

在综合条件下，增删操作相当时且数据的随机性强时，三节点的非平衡性缓冲效果越明显，因此红黑树的综合性能更优。





## 红黑树的概念

红黑树（Red–black tree）是一种平衡二叉搜索树，它通过颜色的约束来维持着二叉树的平衡。

红黑树的另一种定义是含有红黑链接并满足下列条件的二叉查找树：

- 性质1：每个节点或者是黑色，或者是红色。
- 性质2：根节点是黑色
- 性质3：每个叶节点都是黑色（叶节点指NIL节点）
- 性质4：如果一个节点是红色的，则它的子节点必须是黑色的，即一条路径上不能出现相邻的两个红色结点。
- 性质5：从任一节点到其每个叶节点的所有路径都包含相同数目的黑色节点



性质4和性质5作为约束，可以保证从根节点到叶节点的最长可能路径不多于最短的可能路径的两倍长。

分析：当某条路径最短时，这条路径必然都是由黑色节点构成。当某条路径长度最长时，这条路径必然是由红色和黑色节点相间构成，性质5保证了这两条路就的黑色节点数量相同，所以最长路径的长度是最短路径的两倍。

因此，红黑树大致上是平衡的，但并不严格，因为它不是严格控制左、右子树的高度之差小于等于1

n个节点的红黑树的高度至多是 $2log_2(n+1)$，所以高度在 $O(logN)$ 级别



## 红黑树与2-3-4树的对应关系

红黑树起源于2-3-4树，它的本质其实就是2-3-4树

<img src="http://store.secretcamp.cn/uPic/image-20210104193019676202101041930201609759820okU2XDokU2XD.png" alt="image-20210104193019676" style="zoom: 38%;" />



<img src="http://store.secretcamp.cn/uPic/image-20210106102950414202101061029501609900190iMzWVgiMzWVg.png" alt="image-20210106102950414" style="zoom:40%;" />



2-3-4树转红黑树

<img src="http://store.secretcamp.cn/uPic/image-20210104194747287202101041947471609760867w29M8mw29M8m.png" alt="image-20210104194747287" style="zoom: 43%;" />







## 旋转与颜色调整

通过红黑树的定义，可以看到红黑树本质上还是一颗二叉搜索树，所以，对红黑树的插入删除操作都可以分为两阶段来完成。

第一阶段，将红黑树看成一颗普通的二叉查找树，完成插入删除操作。

第二阶段，通过 `旋转` 以及 `颜色调整` 来使得操作后的树满足红黑树的所有特性。



### 情况一

插入的新节点是红黑树的根节点，这种情况下，直接将新节点的颜色由红色变为黑色，满足红黑树的性质二



### 情况二

新节点的父节点是黑色，性质4和性质5没有受到影响，不需要调整。

<img src="http://store.secretcamp.cn/uPic/image-20210105201544184202101052015441609848944nBrDj3nBrDj3.png" alt="image-20210105201544184" style="zoom: 50%;" />

### 情况三

插入新节点D，性质 4 被打破，节点 D 的父节点 B 和叔叔节点 C 均为红色，祖父节点 A 为灰色

无需旋转，将父节点 B 和叔叔节点 C 转为灰色，将祖父节点 A 转为红色，如果祖父节点 A 是红黑树的根节点，则再次转为灰色

<img src="http://store.secretcamp.cn/uPic/image-20210105193408455202101051934081609846448TDJIw6TDJIw6.png" alt="image-20210105193408455" style="zoom: 40%;" />





### 情况四

插入新节点 C，节点 C 的叔叔节点非红，且父节点 B 和祖父节点 A 均为左重（即偏向同一个方向）

对祖父节点 A 进行右旋操作，再交换新根节点与旧根节点的颜色

<img src="http://store.secretcamp.cn/uPic/image-20210105200642862202101052006431609848403sS09P1sS09P1.png" alt="image-20210105200642862" style="zoom:40%;" />



可能会有以下情况：

以C为根节点的子树中插入了新节点，经过调整后，导致节点C被变为红色，进而导致了以下情况的产生，事实上C有两个黑色的子节点，这样才能保证黑色平衡。

在这种情况下，应该将以C为根节点的子树视为一个整体，正常进行旋转、变色操作即可。

<img src="http://store.secretcamp.cn/uPic/image-20210106104423605202101061044231609901063u8JYCZu8JYCZ.png" alt="image-20210106104423605" style="zoom:50%;" />



### 情况五

插入新节点C，节点C的叔叔节点非红，且祖父节点A左重，父节点B右重（即偏向不同方向）

先对父节点B进行左旋操作，转化为 "情况四"，之后再对祖父节点A右旋操作，并交换颜色

![image-20210105200721316](http://store.secretcamp.cn/uPic/image-20210105200721316202101052007211609848441MgBVmHMgBVmH.png)









# B-Tree🐿

## B-Tree的概念

B-Tree 即为 B 树，B 为 Balanced，意指平衡，B 树是一种多路平衡搜索树。

B-Tree的特点：

- 所有节点关键字是按递增次序排列，并遵循左小右大原则
- 所有叶子节点均在同一层
- 叶子节点除了包含关键字和关键字记录的指针外，也有指向其子节点的指针，只不过其指针地址都为null

<img src="http://store.secretcamp.cn/uPic/image-20210310222113418202103102221131615386073cLfFmRcLfFmR.png" alt="image-20210310222113418" style="zoom: 45%;" />

B-Tree中 每个节点包含的关键字增多，层级变少，特别是在 B-Tree 应用到数据库中的时候，数据库充分利用了磁盘块的原理

把节点大小限制和充分使用在磁盘快大小范围，可以减少数据查找的次数和复杂度。

> 磁盘数据存储采用块的形式，每个块的大小为 4K，每次 I/O 进行数据读取时，同一个磁盘块的数据可以一次性读取出来



## 2-3树

2-3 树是一种多叉树，也是一种平衡搜索树，是最简单的 B-Tree 结构，2-3 树是三阶 B-Tree

2-3 树的特点：

- 所有叶节点都拥有相同的深度（只要是B树都满足这个条件）
- 节点右二节点、三节点构成
  - 有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点，二节点有且仅有一个数据项
  - 有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点，三节点有且仅有两个数据项
- 元素始终保持排序顺序，整体上保持二叉查找树的性质

构建规则：

当按照规则插入一个数到某个节点时，不能满足2-3树的构建要求，就需要拆节点，先向上拆，如果上层满，则拆本层，拆后仍然需要满足2-3树的条件。



## 2-3-4树

2-3-4 树是四阶的 B-Tree，是一种多路查找树。

2-3-4 树的特点：

- 所有叶节点都拥有相同的深度（只要是B树都满足这个条件）
- 节点由二节点、三节点、四节点构成
  - 有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点，二节点有且仅有一个数据项
  - 有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点，三节点有且仅有两个数据项
  - 有四个子节点的节点叫四节点，四节点要么没有子节点，要么有三个子节点，四节点有且仅有三个数据项
- 元素始终保持排序顺序，整体上保持二叉查找树的性质



# B+Tree🐿

## B+Tree的概念

B+Tree 是基于 B-Tree 和叶子节点顺序访问指针进行实现，它具有 B-Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。



B+Tree 的特点：

- B+Tree 的非叶节点不保存关键字记录的指针，只进行数据索引，这样使得 B+Tree 每个非叶节点所能保存的关键字大大增加；
- B+Tree 的叶节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到，所以每次数据查询的次数都一样；
- B+Tree 叶节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。

在 B+Tree 中，一个节点中的 $key$ 从左到右非递减排列，如果某个指针的左右相邻的 $key$ 分别是 $key_i$ 和 $key_{i+1}$，且不为 null，则该指针指向节点的所有 $key$ 大于等于 $key_i$ 且小于等于 $key_{i+1}$。

<img src="http://store.secretcamp.cn/uPic/image-20210214151137791202102141511381613286698N08NYdN08NYd.png" alt="image-20210214151137791" style="zoom: 50%;" />



## 与B-Tree的比较

1. B+Tree 的层级更少

   相较于 B-Tree，B+Tree 每个非叶子节点存储的索引更多，树的层级更少所以查询数据更快；

2. B+Tree 查询速度更稳定

   B+Tree 所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比 B-Tree 更稳定

3. B+Tree 天然具备排序功能

   B+Tree 所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B-Tree高。

4. B+Tree 全节点遍历更快

   B+Tree 遍历整棵树只需要遍历所有的叶子节点即可，而不需要像 B-Tree 一样需要对每一层进行遍历，这有利于数据库做全表扫描。

B-Tree 相对于 B+Tree 的优点是，如果经常访问的数据离根节点很近，而 B-Tree 的非叶子节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比 B+Tree 快。



## 与红黑树的比较

1. B+Tree 有更低的树高

   平衡树的树高 $O(h)=O(log_dN)$，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+Tree 的出度一般都非常大，所以红黑树的树高明显比 B+Tree 大非常多。

2. 磁盘访问原理

   操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。

   如果数据不在同一个磁盘块上，那么通常需要移动制动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取时间。B+Tree 相对于红黑树有更低的树高，进行寻道的次数与树高成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以 B+Tree 更适合磁盘数据的读取。

3. 磁盘预读特性

   为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。并且可以利用预读特性，相邻的节点也能够被预先载入。



## 查找删除操作

进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data 。

插入删除操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性。



# 图论🐿

## 图的基本概念

- 顶点

  顶点（vertex）是图的基本组成部分，顶点具有名称标识key，也可以携带数据项value

- 边

  边（edge）作为2个顶点之间关系的表示，边连接两个顶点。边可以是无向或者有向的，相应的图称作 "无向图" 和 "有向图"

- 权重

  为了表达从一个顶点到另一个顶点的 "代价"，可以给边赋权（Weight）

- 图

  一个图（grahy）可以定义为 $G = (V,E)$ ，其中V是顶点的集合，E是边的集合，E中的每条边 $e = (v, w)$ ，其中 v 和 w都是V中的顶点，这表示一堆响铃；



## 图的抽象数据类型

### 邻接矩阵

矩阵的每行和每列都代表图中的顶点，如果两个顶点之间有边相连，设定行列值。

邻接矩阵实现简单，可以很容易得到顶点是如何相连，但是大多数问题所对应的图都是稀疏的，很容易编程稀疏矩阵，浪费空间

<img src="http://store.secretcamp.cn/uPic/image-20210902102853591202109021028541630549734wpbOKewpbOKe.png" alt="image-20210902102853591" style="zoom:50%;" />



### 邻接列表

维护一个包含所有顶点的主列表（master list），主列表中的每个顶点，再关联一个与自身有边连接的所有顶点的列表

邻接列表法的存储空间紧凑高效，很容易获得顶点所连接的所有顶点，以及连接边的信息。

<img src="http://store.secretcamp.cn/uPic/image-202109021030581002021090210305816305498586xZjNL6xZjNL.png" alt="image-20210902103058100" style="zoom:50%;" />





## 广度优先搜索

给定图 G，以及开始搜索的起始顶点s

BFS 搜索所有从 s 可到达顶点的边，而且在达到更远的距离 k+1 的顶点之前，BFS 会找到全部距离为 k 的顶点

BFS 需要使用队列来实现：

```java
public void breathFirstSearch(T start) {
    Vertex<T> startVertex = getVertex(start);
    startVertex.setDistance(0);
    startVertex.setPredecessor(null);
    Queue<Vertex<T>> queue = new Queue<>();
    queue.enqueue(startVertex);  // 将起始节点加入队列
    while (queue.size() > 0) {  // ---> 当所有节点出队列后，算法结束
        Vertex<T> item = queue.dequeue();  // 取队首作为当前节点
        Set<Vertex<T>> neighbours = item.getConnections();  // 获取邻接节点并遍历
        for (Vertex<T> neighbour : neighbours) {
            if (neighbour.getColor().equals(WHITE)) {
                neighbour.setDistance(neighbour.getDistance() + 1);
                neighbour.setPredecessor(item);
                neighbour.setColor(GRAY);
                queue.enqueue(neighbour);  // 当前节点入队列
            }
        }
        item.setColor(BLACK);
    }
}
```



## 深度优先搜索

深度优先搜索是沿着树的单支尽量深入向下搜索，如果到无法继续的程度还未找到问题解，就回溯上一层再搜索下一分支。



### 骑士周游问题

骑士周游问题是一种特殊的对图进行深度优先搜索，其目的是建立一个没有分支的最深的深度优先树，表现为一条线性的包含所有节点的退化树。



如果沿着单个分支深入搜索到无法继续时（所有合法移动都已经被走过），路径长度还没有达到预定值（如果是 8×8 的棋盘，那么要走63步），那么就清除颜色标记，返回到上一层，换一个分支继续深入搜索。

如果没有一条有效路径，最后所有的节点都会恢复成白色，同时栈空。



## 最短路径

### Dijkstra算法

解决带权最短路径问题的经典算法是以发明者命名的 Dijkstra 算法

给出加权连通图中一个顶点，称之为起点，找出起点到其它所有顶点之间的最短距离。这是一个迭代算法，计算出从一个顶点到其余所有顶点的最短路径，很接近于广度优先搜索算法。

Dijkstra 算法思想：在 n 个顶点的有向带权图中，采用贪心法思想，进行 n-1 次查找，第一次进行查找，找出距离起点最近的一个顶点，标记为已遍历；下一次进行查找时，从未被遍历中的顶点寻找距离起点最近的一个顶点， 标记为已遍历；直到 n-1 次查找完毕，结束查找，返回最终结果。


```java
public class DijkstraVer {
    /**
     * 记录当前问题规模下的最短路径
     */
    int[] res;
    /**
     * 记录哪些顶点被访问过
     */
    boolean[] used;

    public static void main(String[] args) {
        int[][] graph = new int[][]{
                {0, 4, 6, 0, 0, 0},
                {0, 0, 0, 5, 4, 0},
                {0, 0, 0, 4, 7, 0},
                {0, 0, 0, 0, 5, 7},
                {0, 0, 0, 0, 0, 5},
                {0, 0, 0, 0, 0, 0}};
        DijkstraVer2 main = new DijkstraVer2();
        int n = graph.length;
        main.res = new int[n];
        main.used = new boolean[n];
        main.dijkstra(graph, 0);
    }

    /**
     * 图通过邻接矩阵实现
     */
    private void dijkstra(int[][] graph, int start) {
        int n = graph.length;
        // 出发点标记为P标号
        used[start] = true;
        // 初始化结果集
        System.arraycopy(graph[start], 0, res, 0, n);

        // 从start出发，遍历每一个T标号的值
        for (int i = 0; i < n; i++) {
            if (used[i]) continue;
            int min = Integer.MAX_VALUE; // start->k 路线的最短距离
            int k = 0; // start距离其他拥有T标号顶点中最短的那个
            // 从所有T标号中，找一个最小的，即找到start到其它顶点中距离最小的一个顶点k
            // 以k作为中介去更新start到别的顶点的距离
            for (int j = 0; j < n; j++) {
                //
                if (!used[j] && res[j] < min && res[j] != 0 && j != start) {
                    min = res[j];
                    k = j;
                }
            }
            // 尝试从k出发找一条相邻的边，构成路线 start->k->j
            // 看 start->k->j 和 start ->j 两条路线的距离，如果start->k->j更短，则更新
            // 将顶点start到其它顶点的距离与加入中间顶点k之后的距离进行比较，更新最短距离
            for (int j = 0; j < n; j++) {
                if (used[j] || graph[k][j] == 0) continue;
                if (min + graph[k][j] < res[j] || res[j] == 0) {
                    res[j] = min + graph[k][j];
                }
            }
            // 相当于将T标号转化为P标号
            used[k] = true;
        }
        System.out.println(Arrays.toString(res));
    }
}
```



### Floyd算法





## 最小生成树

最小生成树的三种算法都是基于贪心思想，每一步选择局部最优，从而期望得到全局最优的算法。

如果组合优化问题满足拟阵的结构，则可以使用适当的贪婪算法得到最优解，如以下三个算法，不满足拟阵结构的问题，贪婪算法可能得不到最优解，如旅行商问题（TSP）。



### Prim算法

从图 G 中的「任意点」开始，选择关联的权重最小且不生成圈的边添加，直到得到最小生成树。



### Kruskal算法

从 G 中的「最小边」开始，进行避圈式扩张。



### 管梅谷算法（破圈法）

从图 G 的「任意圈」开始， 去掉该圈中权值最大的一条边，称为破圈。不断破圈，直到 G 中没有圈为止，最后剩下的 G 的子图为 G 的最小生成树。



# 布隆过滤器🐿

布隆过滤器（Bloom Filter）是一个由位数组和一系列哈希函数组成的数据结构。

相比平时常用的的 List、Map 、Set 等数据结构，它占用空间更少并且效率更高，但是缺点是其返回的结果是概率性的，而不是非常准确的。理论情况下添加到集合中的元素越多，误报的可能性就越大。并且，存放在布隆过滤器的数据不容易删除。

位数组中的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1 。这样申请一个 100 万个元素的位数组只占用 `1000000Bit / 8 = 125000 Byte = 125000/1024 kb ≈ 122kb` 的空间。



## 实现原理

当一个元素加入布隆过滤器中的时候，会进行如下操作：

1. 使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。
2. 根据得到的哈希值，在位数组中把对应下标的值置为 1 。



当判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：

1. 对给定元素再次进行相同的哈希计算；
2. 得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。

因此，当字符串存储要加入到布隆过滤器中时，该字符串首先由多个哈希函数生成不同的哈希值，然后将对应的位数组的下标设置为 1 。当第二次存储相同字符串时，因为先前的对应位置已设置为 1，所以很容易知道此值已经存在。



综上，可以得出结论：布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。



## 使用场景

1. 判断给定数据是否存在

   例如判断一个数字是否存在于包含大量数字的数字集中（数字集很大）、 防止缓存穿透、邮箱的垃圾邮件过滤、黑名单功能等。

2. 去重

   例如爬给定网址的时候对已经爬取过的 URL 去重。



## 扩容

因为布隆过滤器的不可逆，我们没法重新建一个更大的布隆过滤器然后去把数据重新导入。这边采取的扩容的方法是，保留原有的布隆过滤器，建立一个更大的，新增数据都放在新的布隆过滤器中，去重的时候检查所有的布隆过滤器。



## 删除数据

布隆过滤器中数据的删除不是随意的，只能根据一定的规则。

如果有这样一个需求：使用布隆过滤器对 url 去重，但是每五个月要重新爬取一次。

可以使用多个布隆过滤器，每个月都清空最早的那个过滤器。去重时也必须遍历每一个布隆过滤器





# 并查集🐿

并查集主要是为了解决动态连通性问题，用一个数组来表示连通的集合。

具体的实现是使用一个数组来记录父节点，如果父节点是本身，那么这个值就代表一个集合。







# 线段树🐿

线段树是一个完全二叉树，它的基本含义是，用结点所在位置表示一个范围，二叉树的根结点位置表示从 left 到 right 的范围，结点的值代表这个范围之上的属性，如最大值。

这里的二叉树采用的是数组的形式实现。





# 海量数据问题🐿

## 海量数据全排序

一共有十亿条数据，最小是 0，最大的是 999999999 ，即最大是 9 位整数。

1. 分段排序

   通过 hash 将十亿数据分为 100 段，每一段大约 1000 万条。

   在文件中依次搜索 0 - 1000w， .......，9000w - 10000w 

   每一段数据搜索 100 次 ，搜索 100 段数据， 一共 10000 次，时间复杂度 0(n^2) 。

2. 数据库排序

   导入数据库，让数据库进行索引排序操作后提取数据到文件。

3. 位图法🐮

   声明一个可以包含 9 位整数的 bit 数组，数组长度为 10亿，每一位为 1 代表数字存在，为 0 代表数字不存在。

   > 也可以直接申请 2^32 位，直接覆盖整个 int 范围

   例如读到一个数据为 10000，则找到对应的 bit （即从低位往高位数 10000 次），将该 bit 置为 1，

   第一次遍历所有的数，将出现的数字在位图中对应的位置置为 1。

   第二次遍历位图，依次输出值为 1 的位对应的数字，全部输出完就是排好了。

   

   位图法需要内存空间很小：

   `1 mb = 1024 kb = 8 * 1024 * 1024 bit =  8388608 bit`

   十亿数据需要的空间为 `1000000000 / 8388608= 119 mb`

   

## 海量数据topk

堆排序：假设求最大的 k 个数据，则创建一个容量为 k 的最小堆，一直往里面塞数据，因为最小值在堆顶，如果有大的进来，就把小的弹出，最后剩下的就是最大的 k 的数据，时间复杂度 O(n)



## 海量实整数找相同

在十亿个整数中找出不重复的整数，内存不足以放下所有的数。

采用两位的位图法，为每个数分配两位，00 表示没有出现，01 表示出现一次，10 表示出现多次，11 没有意义。

总共需要 `2^31 * 2 = 2147483647 * 2 / 8388608 = 512mb` ，没有限制整数的范围，则必须把 31 位都考虑进去。

第一次遍历位图，扫描十亿个整数，查看位图中相对应的位，如果是 00 就变为 01，如果是 01 就变为 10，其他情况保持不变。

第二次遍历位图，01 对应的就是只出现了一次的整数

当然也可以找重复的数，10 对应的就是重复的整数







## 海量URL找相同

给定 a、b 两个文件，各存放 50 亿 个 url，每个 url 各占 64 字节，内存限制是 4G，找出 a、b 文件中共同的 url。

1. 分治

   单个文件的大小： `5000000000 * 64 / 1024 * 1024 * 1024 = 298 G` ，约300 G

   遍历文件 a，对每个url 取 hash，映射到 0 - 999 ，根据 hash 值将 url 存储到 1000 个小文件中，每个小文件的大小是 0.3 G

   遍历文件 b，对每个url 取 hash，映射到 0 - 999 ，根据 hash 值将 url 存储到 1000 个小文件中，每个小文件的大小是 0.6 G

   小文件的大小小于内存限制，所以可以将每个小文件加载到内存中处理，经过以上 hash 处理后所有可能相同的 url 都在对应的小文件，不对应的小文件不可能有相同的 url 。

   

2. 布隆过滤器

   如果允许有一定的错误率，可以使布隆过滤器

   4G 内存可以表示的位图位数为：`4 * 1024 * 1024 * 1024 * 8 = 34359738368 bit` ，约 343 亿 bit

   将 343 亿 bit 作为布隆过滤器，遍历文件 a，将所有 URL 映射到布隆过滤器中。

   遍历文件 b，检查布隆过滤器的返回值，如果为 true ，则表示是相同的 url （有一定误判概率）

   ❗限制：布隆过滤器也要求一次性申请全部长度的内存，如果内存限制更小，比如 1G，512M，或者数据量更大，那布隆过滤器也无法满足

 



## 找到某条数据

现在有 10000 的个数，从中拿掉一个数，还剩 9999 个数，现在用一个数组来存储这 9999 个数，问怎么才能找出拿掉的数？





# 计算技巧🐿

## 辗转相处计算最大公约数

```java
    private static int findDivisor(int a, int b) {
        int tmp = a;
        for (int i = 1; i < tmp; i++) {
            int c = Math.max(a, b);
            int d = Math.min(a, b);
            // 余数
            a = c % d;
            // 除数
            b = d;
            // 余数为0则除数就是最大公约数
            if (a == 0) {
                return d;
            }
        }
        return 1;
    }
```





## 因子分解

对 v 因子分解：12 = 2 * 2 * 3

```java
int v = sc.nextInt();

for (int j = 2; j <= v / 2; ++j) {
    while (v % j == 0) {
        v /= j;
        ++record[j];
    }
}
if (v > 1) {
    ++record[v];
}
```

