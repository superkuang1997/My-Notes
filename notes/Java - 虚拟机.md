# Java虚拟机⛩

JVM 是可运行 Java 代码的假想计算机，是运行在操作系统之上的，它与硬件没有直接的交互。

Java 源文件通过编译器能够生产相应的 .Class 文件，即字节码文件，而字节码文件又通过 Java 虚拟机中的解释器，编译成特定机器上的机器码。

- Java源文件 —-> 编译器 —-> 字节码文件

- 字节码文件 —-> JVM —-> 机器码



# 内存空间概念

JVM 在执行 java 程序时会将它所管理的内存空间划分为若干的区域，有的区域随着虚拟机进程的启动而存在，有的区域则依赖用户线程的启动和结束而建立和销毁。

<img src="http://store.secretcamp.cn/uPic/image-20201222152415523202012221524151608621855ZoHu5YZoHu5Y.png" alt="image-20201222152415523" style="zoom: 33%;" />



## 程序计数器

程序计数器是一块较小的内存空间，是当前线程所执行字节码文件的行号指示器，生命周期与线程相同。

JVM 的多线程是通过「线程轮流切换并分配处理器的执行时间」来实现的，在任何一个确定的时刻，一个处理器、或者多核处理器的一个核心都只会处理一个线程中的指令，为了在切换线程后能够恢复到正确的执行位置，每一个线程都有一个独立的程序计数器。

程序计数器指向方法区中存储了指向下一条指令的地址，也即将要执行的指令代码，然后由执行引擎读取下一条指令。

如果执行的是一个 Native 方法，那么程序计数器是空的。

各条线程之间的计数器互不影响名独立存储，所以对应的内存空间是线程私有的

> 程序计数器是唯一不会出现 OutOfMemoryError 的内存区域。



## 虚拟机栈

java虚拟机栈是线程私有的，生命周期与线程相同。

一种粗糙的分类是将JVM的空间分为堆内存、栈内存和方法区，栈内存指的就是虚拟机栈，或者就是指虚拟机栈中的局部变量表



### 栈帧

栈中的数据都是以栈帧（Stack Frame）的形式存在，栈帧是一个内存区块，是一个有关方法和运行期数据的数据集。

每个方法在执行的同时会创建一个栈帧，用于存储方法执行过程中的局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调用至执行完成的过程，对应一个栈帧从入栈到出栈的过程。

- 局部变量表：存放了编译期可知的各种 Java 虚拟机基本数据类型、对象引用、方法返回地址
- 操作数栈：进行运算时存放数据的空间
- 动态连接：指向常量池的引用
- 方法返回地址：当前方法返回后的数据存放的地方



### 局部变量表

- 基本数据类型

  八种基本数据类型，其中 long 和 double 类型会占用 2 个局部变量空间（slot），其他类型只占用1个slot

- 对象引用

  指向对象起始位置的引用指针

- returnAddress类型

  指向一条字节码指令的地址



## 本地方法栈

本地方法栈是线程私有的，生命周期与线程相同。

作用与虚拟机栈类似，虚拟机栈是为 JVM 执行 java 方法服务，而本地方法栈则是为了 JVM 用到的 Native 方法服务。

Native方法：java 调用的非 java 代码的方法



## Java堆

java堆内存空间被所有线程共享，是java虚拟机管理的内存中最大的一块，在虚拟机启动时创建，该空间的唯一目的就是存放对象的实例。由于java堆是垃圾回收机制的主要作用区域，所以也被成为 GC 堆。

如果 java 堆中没有内存完成对象实例化，并且堆无法再扩展，则会抛出 `OutOfMemoryError` 异常

堆内存分为三个部分：

- `Eden Space`（伊甸园）
- `Survivor Space`（幸存者区，分为 `From Survivor` 和 `To Survivor` ） 
- `Old Gen`（老年代）

其中，`Eden` 、`Survivor` 区属于新生代。



## 方法区

方法区是线程共享的内存区域，用于存储已经被虚拟机加载的类结构信息，例如运行时常量池、字段和方法数据、构造函数和普通方法的字节码内容。

方法区中主要保存以下内容：

- 类型信息

  - 类的完整名称（比如，`java.lang.String`）

  - 类的直接父类的完整名称

  - 类的直接实现接口的有序列表（因为一个类直接实现的接口可能不止一个）

  - 类的修饰符

- 字段信息

  - 声明的顺序
  - 修饰符
  - 类型
  - 名字

- 方法信息

  - 声明的顺序
  - 修饰符
  - 返回值类型
  - 方法名
  - 参数列表
  - 异常表（方法抛出的异常）
  - 方法字节码（native、abstract方法除外）
  - 操作数栈和局部变量表大小

- 类变量

  - 非 final 类变量（JDK 1.8 之前）

    在 java 虚拟机使用一个类之前，它必须在方法区中为每个非 `final` 类变量分配空间，即非 `final` 类变量存储在定义它的类中；

  - final 类变量（不存储在这里）

    由于 `final` 的不可改变性，因此，`final` 类变量的值在编译期间就被确定了，因此被保存在类的常量池里面，然后在加载类的时候，复制进方法区的运行时常量池里面。`final` 类变量存储在「运行时常量池」里面，每一个使用它的类保存着一个对其的引用；

- 对类加载器的引用

  JVM 必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的，如果一个类型是由用户类加载器加载的，那么 JVM 会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。

- 对 Class 类的引用

  JVM 为每个加载的类都创建一个 `java.lang.Class` 的实例（存储在堆中）。而 JVM 必须以某种方式把 Class 的这个实例和存储在方法区中的类型数据（类的元数据）联系起来， 因此，类的元数据里面保存了对 Class 对象的引用。

- 运行时常量池



## 方法区的变迁

### 部分数据移入堆内存

*JDK 1.7* 中，为了迎合将来移除永久代的需要，有部分数据被移入了堆中，而不是存放在元空间。

- 字符串常量池
- 静态常量池
- 静态变量： 被移入堆中的 Class 对象中



### 移除永久代改用元空间

*JDK 1.7* 及之前，永久代（PermGen）是 HotSpot 虚拟机对方法区的实现，

*JDK 1.8* 之后取消了永久代，取而代之的是元空间（Metaspace），元空间和作用和永久代类似，它们之间最大的区别在于元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。

为什么要移除永久代，转而使用元空间？

- 很多类是在运行期间加载的，这部分类加载的空间不可控，如果这部分内存是在 JVM 内存里分配的话，永久代大小是固定的，如果分配太大那么 JVM 其他区域（比如说堆）的内存就会变小，容易导致老年代内存溢出，反之如果设置太小，就容易出现方法区内存溢出。
- 字符串常量池存在永久代中，容易出现性能问题和内存溢出。（后移入堆中）
- 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。

<img src="http://store.secretcamp.cn/uPic/image-20210421183600465202104211836001619001360dTCyzUdTCyzU.png" alt="image-20210421183600465" style="zoom: 30%;" />



## 常量池

常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享，例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。

- 节省内存空间： 常量池中所有相同的字符串常量被合并，只占用一个空间。

- 节省运行时间： 比较字符串时，`==` 比 `equals` 快，对于两个引用变量，只用 `==` 判断引用是否相等，也就可以判断实际值是否相等。

*JDK1.7* 字符串常量池、静态变量被从方法区移到堆中

*JDK1.8* 移除了永久代，运行时常量池移至元空间



### 静态常量池

字节码文件中除了有类的字段、方法、接口等描述信息外，还有常量池，用于存放编译器生成的各种字面量和符号引用，这被称为静态常量池（The Constant Pool），即字节码文件中的常量池，这种常量池主要用于存放两大类常量：字面量和符号引用

这里说静态，是为了和运行时常量池作区分。

- 字面量：接近于Java语言常量概念
- 符号引用：编译原理方面的概念
  - 类和接口的全限定类名
  - 字段的名称和描述符
  - 方法的名称和描述符



### 运行时常量池

运行时常量池（Runtime Constant Pool）是方法区的一部分，jvm 在完成类加载操作后，将字节码文件中的静态常量池载入到内存，并保存在方法区中，我们常说的常量池，一般就是指方法区中的运行时常量池。

字节码文件中的常量池是静态的，但是运行时常量池是动态的，程序开始运行时，字节码文件中常量池的所有常量会进入运行时常量池，程序运行过程中，也可能有新的常量加入池中。

运行时常量池相对于静态常量池的另外一个重要特征是具备动态性，Java 语言并不要求常量一定只有编译期才能产生，也就是并非预置在字节码文件中静态常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是 `String` 类的 `intern` 方法。

`String` 的 `intern` 方法会查找在常量池中是否存在一份 equal 相等的字符串，如果有则返回该字符串的引用，如果没有则添加自己的字符串进入常量池。



### 字符串常量池

静态常量池在类加载后相关数据进入运行时常量池，但是字符串常量有些特殊，它会进入字符串常量池之中。

JVM 为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化，为字符串开辟一个字符串常量池，类似于缓冲区，创建字符串常量时，首先检查字符串常量池是否存在该字符串，如果存在，则返回引用实例，不存在，实例化该字符串并放入池中。

字符串常量池中有一个全局表，总是为池中每个唯一的字符串对象维护一个引用，这就意味着它们一直引用着字符串常量池中的对象，所以，在常量池中的这些字符串不会被垃圾收集器回收。

*JDK 1.7* 之后，Hotspot 把永久代中的字符串常量池、静态变量迁移到了堆中。



## 直接内存

需要注意的是，直接内存不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。

在 *JDK 1.4* 新加入了 NIO 类，引入了一种基于通道（Channel）和缓冲区（Buffer）的 I/O 方式，它可以使用 Native 函数直接分配堆外内存，然后通过一个存储在 Java 堆中的 `DirectByteBuffer` 对象作为这块内存的引用进行操作，可以提高性能，因为避免了 Java 堆和 Native 堆中来回赋值数据。

该区域不受堆大小限制但是会受到本机总内存（RAM）大小等限制。如果忽略这点将堆大小设置过大使得各个内存区域大小总和大于物理内存，它会在动态扩展时出现 `OutOfMemoryError` 异常。







# 对象⛩

<img src="http://store.secretcamp.cn/uPic/image-20201222162850502202012221628511608625731Td0ufRTd0ufR.png" alt="image-20201222162850502" style="zoom:33%;" />



## 对象的创建

```java
public class Person {
    // 静态变量
    public  static  int staticVariable = 1;
    // 成员变量
    public int objVariable;
    // 静态初始代码块
    static {
        staticVariable = 2;
    }
    // 对象初始化代码块
    {
        objVariable = 88;
    }
    // 构造方法
    public Person() {
        objVariable = 99;
    }
    public static void main(String[] args) {
        Person person = new Person();
    }
}
```



1. 执行到 `new` 关键字，开始创建对象。
2. 检查能否在运行时常量池中定位到一个类的符号引用，然后检查这个符号引用代表的类是否被加载、解析和初始化。
3. 如果没有，则先进行类加载。
4. 类加载检查通过后，虚拟机类元信息先确定对象的大小，在堆中为新的对象分配内存，同时向对象成员变量赋默认值。

此时从 java 虚拟机的角度来看，新的对象已经创建完成了，但从 java 程序的视角来看，构造函数，即字节码文件中的 `<init>()` 方法还没有开始执行，所有的字段还都是默认的零值。

1. 初始化对象：执行对象内部生成的 init 方法，初始化成员变量值，同时执行搜集到的 {} 代码块，最后执行对象构造方法
2. 引用对象：对象实例化完毕后，再把栈中的对象引用地址指向该对象在堆内存中的地址。



## 内存分配方法

在为对象分配内存时，主要有两种方法：

- 指针碰撞：如果 java 堆中的内存是规整的，所有已使用的内存放在一边，闲置的内存方在另一边，中间用一个指针作为分隔，分配内存给对象实例时，移动指针的位置。

- 空闲列表：如果 java 堆中的内存不是规整的，已使用的内存和未使用的内存相互交错，虚拟机就必须维护一个列表，列表中记录可用的内存块，进行分配时从列表中找到一块足够大的内存空间分配给对象实例。

可见选择哪种方法，取决于 java 堆的可用内存是否规整，而java堆是否规整，又取决于选择的垃圾收集算法。



### 保证内存分配的线程安全

- 同步：基于CAS（Compare AND Swap，比较并交换）以及失败重试。
- 进行内存的预分配，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB），当线程需要分配内存时，则在 TLAB 上进行分配，只有 TLAB 用完时才需要同步。





## 对象的内存布局

对象在内存中储存的布局可以分为三块区域

- 对象头（header）
- 实例数据（instance data）
- 对齐填充（padding）



### 对象头

对象头中一般分为两个部分：Mark Word 以及 Klass Word

```ruby
	普通对象
|--------------------------------------------------------------|
|                     Object Header (64 bits)                  |
|------------------------------------|-------------------------|
|        Mark Word (32 bits)         |    Klass Word (32 bits) |
|------------------------------------|-------------------------|
  
	数组对象
|---------------------------------------------------------------------------------|
|                                 Object Header (96 bits)                         |
|--------------------------------|-----------------------|------------------------|
|        Mark Word(32bits)       |    Klass Word(32bits) |  array length(32bits)  |
|--------------------------------|-----------------------|------------------------|
```



#### Mark Word

Mark Word 用于存储对象自身的运行时数据，如哈希值、GC分代年龄、锁状态标志等，这部分数据的长度为32bit 或者 64bit。

由于 Mark Word 所存储的信息与对象自身定义无关，考虑到空间效率，MarkWord 会根据对象的状态复用自己的存储空间，对象处于不同的状态时，数据存储的含义不同。

以 32bit 的为例：

```ruby
|-------------------------------------------------------|--------------------|
|                  Mark Word (32 bits)                  |       State        |
|-------------------------------------------------------|--------------------|
| identity_hashcode:25 | age:4 | biased_lock:1 | lock:2 |       Normal       |
|-------------------------------------------------------|--------------------|
|  thread:23 | epoch:2 | age:4 | biased_lock:1 | lock:2 |   Biased Locked    |
|-------------------------------------------------------|--------------------|
|               ptr_to_lock_record:30          | lock:2 | Lightweight Locked |
|-------------------------------------------------------|--------------------|
|               ptr_to_heavyweight_monitor:30  | lock:2 | Heavyweight Locked |
|-------------------------------------------------------|--------------------|
|                                              | lock:2 |    Marked for GC   |
|-------------------------------------------------------|--------------------|
```



- identity_hashcode：25位的对象标识 hash 码，采用延迟加载技术。调用方法 `System.identityHashCode()` 计算，并会将结果写到该对象头中。当对象被锁定时，该值会移动到管程 Monitor 中。

- age：4 位的 java 对象年龄。在 GC 中，如果对象在 Survivor 区复制一次，年龄增加1。当对象达到设定的阈值时，将会晋升到老年代。默认情况下，GC 的年龄阈值为 15，最大也只能是 15 。

- thread：持有偏向锁的线程ID

- epoch：偏向时间戳

- ptr_to_lock_record：指向栈中锁记录的指针。

- ptr_to_heavyweight_monitor：指向管程 monitor 的指针。

- biased_lock：对象是否启用偏向锁标记，只占 1 个二进制位。为 1 时表示对象启用偏向锁，为 0 时表示对象没有偏向锁。

- lock：2位的锁状态标记位，由于希望用尽可能少的二进制位表示尽可能多的信息，所以设置了 lock 标记。该标记的值不同，整个mark word表示的含义不同。

  | biased_lock | lock |   状态   |
  | :---------: | :--: | :------: |
  |      0      |  01  |   无锁   |
  |      1      |  01  |  偏向锁  |
  |      0      |  00  | 轻量级锁 |
  |      0      |  10  | 重量级锁 |
  |      0      |  11  |  GC标记  |

  

#### Klass Word

Klass Word 用于存储类型指针，即对象指向其类的元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，这部分数据的长度为 32bit 或者 64bit。

当然，查找对象的元数据信息也不一定非要通过对象本身。



#### Array Length

如果对象是一个数组，那么对象头还需要有额外的空间用于存储数组的长度，这部分数据的长度为 32bit 或者64bit。



### 实例数据

实例数据是对象真正存储的有效信息，也就是在 java 代码中定义的字段类型

无论是父类中继承的，还是子类中定义的，都需要记录下来。



### 对齐填充

对齐填充不是一定存在的，仅仅起到占位作用，因为 java 虚拟机要求对象的大小必须是 8bit 的整数倍，对象头的大小经过精心设计，肯定是 8byte 的一倍或两倍，但实例数据没有对齐的情况下，就需要进行对齐填充。



## 对象的访问定位

创建对象的目的是为了使用对象，Java 程序会通过栈上的引用来操作堆上的具体对象。

对象的访问有两种方式：

- 使用句柄
- 直接指针



### 使用句柄

java 堆中会分出一块空间作为句柄池，栈中的 reference 存储的是对象的句柄地址，而句柄中又包含了对象实例数据与对象类型数据各自的具体地址信息。

- 对象实例数据：被 new 出来的对象的信息，即对象头、实例数据和对齐填充

- 对象类型数据：被虚拟机加载的类信息，存放在方法区

优点：reference 存储的是稳定的对象句柄地址，即时对象具体地址被移动（GC时移动对象是很普遍的行为），只需要改变句柄中的实例数据指针，而不用改变 reference 本身。

<img src="http://store.secretcamp.cn/uPic/image-20201222162921832202012221629211608625761AQeNLPAQeNLP.png" alt="image-20201222162921832" style="zoom:33%;" />



### 直接指针

栈中的 reference 存储的是对象实例数据的具体地址，对象实例数据中又存储了指向对象类型数据（方法区中）的指针，hotspot 虚拟机使用的是这种方式。

优点：速度更快，节省了一次指针定位的时间开销。由于对象的访问在 Java 中非常频繁，因此这类开销积少成多后也是非常可观的执行成本

<img src="http://store.secretcamp.cn/uPic/image-20201222162939435202012221629391608625779OOimTHOOimTH.png" alt="image-20201222162939435" style="zoom:33%;" />



## 虚拟机参数

### 设置堆空间大小

-Xms512M：设置堆内存初始值为512M

-Xmx1024M：设置堆内存最大值为1024M

> ms 是 memory start 的简称，mx 是 memory max 的简称，分别代表最小堆容量和最大堆容量



### 设置栈空间大小

-Xss128k：设置栈内存最大为128k



### 异常信息

Dump异常快照以及以文件形式导出

-XX:+HeapDumpOnOutOfMemoryError

-XX:HeapDumpPath







# 垃圾回收机制⛩

## 引用的类型

 *JDK1.2* 之前，Java 里面的引用是很传统的定义，如果 reference 类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该 reference 数据是代表某块内存、某个对象的引用。

 *JDK1.2* 之后，Java 对引用的概念进行了扩充：

- 强引用：是最传统的 "引用" 的定义，是在代码中普遍存在的引用，无论什么情况下，垃圾收集器都不会回收强引用的对象。

- 软引用：描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出 OOM。

  *JDK1.2* 版之后提供了 `SoftReference` 来实现软引用。

- 弱引用：也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次 GC 发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。

- 在 *JDK1.2* 之后提供了 `Weakreferencez` 类来实现弱引用。

- 虚引用：是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。

  在 *JDK1.2*  版之后提供了 `PhantomReference` 类来实现虚引用



## 引用计数法

给对象中添加一个引用计数器，每当一个地方引用它时，计数器的值就加 1，当引用失效时，计数器的值就减 1

引用计数法并不能解决对象循环引用的问题，java 虚拟机并没有选择这个方法。



## 可达性分析法

通过一系列被称为 "GC Roots" 的对象作为起始点，从这些节点向下搜索，搜索走过的路径被称为引用链，当一个对象到 GC Root 没有任何引用链时，就证明该对象是不可用的。

Java中，GC Roots 主要有以下几种：

- 虚拟机栈中引用的对象（方法参数、局部变量、临时变量等）
- 方法区中类静态属性引用的对象（reference 类型的静态变量）
- 方法区中常量引用的对象（字符串常量池中的引用）
- 本地方法栈中 Native 方法引用的对象
- 持有锁的对象

<img src="http://store.secretcamp.cn/uPic/image-20201224150203868202012241502051608793325gSAAABgSAAAB.png" alt="image-20201224150203868" style="zoom: 70%;" />



## 栈中内存的回收

程序计数器、虚拟机栈、本地方法栈三个区域的内存回收具有确定性

程序计数器、虚拟机栈、本地方法栈三个区域的生命周期与线程相同，栈中的栈帧随着方法的运行和结束进行入栈和出栈操作，每一个栈帧中分配多少内存都是已知的（根据类的结构），因此这几个区域的内存分配和回收都具有确定性，当方法结束或线程结束时，内存自然而然就回收了。

垃圾回收机制主要是对 java 堆中对象占用的内存进行回收



## 方法区内存的回收

方法区也是可以有垃圾回收的，永久代的垃圾回收主要是两部分内容：

- 废弃常量

  某个常量没有被任何 java 对象引用，则可能会被清理出常量池

- 无用的类

  - 该类所有实例都被回收
  - 加载该类的 ClassLoader 已经被回收
  - 该类对应的 `java.lang.Class` 对象没有被任何地方引用，无法在任何地方通过反射访问该类的方法





# 垃圾收集算法⛩

垃圾收集算法是内存回收的方法论



## 分代收集算法

现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。

一般将堆分为新生代和老年代。

- 新生代使用：标记 - 复制算法
- 老年代使用：标记 - 清除 或者 标记 - 整理 算法



回收策略：

- 新生代收集（Minor GC）：回收新生代，Eden 满了就会触发 Minor GC ，执行的速度一般也会比较快，将有用对象复制到 To Survivor 中，同时清空 Eden 区。
- 老年代收集（Major GC）：目前只有 CMS 收集器会有单独收集老年代的行为。
- 混合收集（Mixed GC）：目前只有 G1 收集器会有混合收集的行为。
- 整堆收集（Full GC）：回收整个 Java 堆和方法区，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢10倍以上。



## 标记 - 清除算法

在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。

在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。

在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表。

不足：

- 标记和清除过程效率都不高，且效率随着对象数量增加而降低；
- 会产生大量不连续的内存碎片，导致无法给大对象分配内存。

<img src="http://store.secretcamp.cn/uPic/image-20201224151206568202012241512061608793926IOPyxkIOPyxk.png" alt="image-20201224151206568" style="zoom:67%;" />



## 标记 - 复制算法

将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。

不足：

- 只使用了内存的一半
- 如果对象存活率较高，就要进行较多的复制操作，效率很低
- 如果不想浪费 50% 的空间，就必须有额外的空间进行担保，因此老年代一般不选用这种算法

现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。

HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为8:1:1，保证了内存的利用率达到 90% ，如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。

由于 "标记 - 复制算法" 需要老年代进行担保，所以不能在老年代使用这种算法。

<img src="http://store.secretcamp.cn/uPic/image-20201224151730367202012241517301608794250ObNrdtObNrdt.png" alt="image-20201224151730367" style="zoom:70%;" />





## 标记 - 整理算法

标记过程和 "标记-清除算法" 相同，后续过程让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活的区域，移动存活对象并更新所有引用将会是一种极为负重的操作，而且这些操作必须全程暂停用户应用程序才能进行，这样的停顿被最初的虚拟机设计者形象地描述为「Stop The World」。

<img src="http://store.secretcamp.cn/uPic/image-20201224151628305202012241516281608794188mfXuo8mfXuo8.png" alt="image-20201224151628305" style="zoom:70%;" />

如果像 "标记 - 清除" 算法那样不对存活的对象进行移动和整理的话，产生的内存碎片问题只能依靠更为复杂的内存分配策略来解决，例如类似于磁盘分区，通过 "分区空闲分配链表" 来解决。但这也带来了额外的成本，内存分配时会更加复杂。从 GC 的角度看，不移动对象停顿时间会更短，甚至可以不需要停顿，但是从整个程序的吞吐量来看，移动对象会更划算。

由于内存分配的行为比 GC 要频繁的多，即使不移动对象会使得收集器的效率提升一些，会导致内存分配的耗时增加，从总体来看，总吞吐量仍然是下降的。



## 内存区域划分

堆内存分为三个部分：

- `Eden`（伊甸园）
- `Survivor`（幸存者区）
- `Old Gen`（老年代）



### Eden

对象被创建的时候首先放到 `Eden` ，进行垃圾回收后，不能被回收的对象被放入到空的 `Survivor` 区域。



### Survivor

`Survivor` 用于保存在 `Eden` 内存区域中经过垃圾回收后没有被回收的对象。

`Survivor` 有两个，分别为 `To Survivor` 和 `From Survivor`，这个两个区域的空间大小是一样的。执行垃圾回收的时候 `Eden` 区域不能被回收的对象被放入到空的 `To Survivor` ，同时 `Eden` 区域的内存会在垃圾回收的过程中全部释放，`From Survivor` 里部分不能被回收的对象也会被放入 `To Survivor` ，如果有符合晋升要求的则进入老年代。然后 `To Survivor` 和 `From Survivor` 的标记会互换，始终保证一个 `Survivor` 是空的。

`Eden Space` 和 `Survivor Space` 都属于新生代，新生代中执行的垃圾回收被称之为 `Minor GC` 

<img src="http://store.secretcamp.cn/uPic/image-202102021517089412021020215170916122502297ebNd97ebNd9.png" alt="image-20210202151708941" style="zoom:50%;" />

> 经过一次 Minor GC 后的年轻代内存状况



### Old Gen

`Old Gen` 用于存放新生代中经过多次垃圾回收仍然存活的对象，也有可能是新生代分配不了内存的大对象会直接进入老年代。

对象在 `Survivor` 中每熬过一次 `Minor GC`，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到老年代中。



# 垃圾回收器⛩

垃圾回收器是内存回收的具体实现

以下是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。

- 单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；
- 串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了CMS和G1之外，其它垃圾收集器都是以串行的方式执行。

<img src="http://store.secretcamp.cn/uPic/image-20201224154040651202012241540401608795640TwiNyVTwiNyV.png" alt="image-20201224154040651" style="zoom:50%;" />

## GC中的并发与并行

- 并行（Parallel）：并行描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线程在协同工作，通常默认此时用户线程是处于等待状态。

- 并发（Concurrent）：并发描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾收集器线程与用户线程都在运行。由于用户线程并未被冻结，所以程序仍然能响应服务请求，但由于垃圾收集器线程占用了一部分系统资源，此时应用程序的处理的吞吐量将受到一定影响。



## Serial 收集器

*Serial* 翻译为串行，也就是说它以串行的方式执行。它是单线程的收集器，只会使用一个线程进行垃圾收集工作。

优点：简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。

Serial 收集器是 HotSpot 虚拟机运行在客户端模式下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。

![img](https://camo.githubusercontent.com/32b65e211e072f43c474c3787c2a6f1bbf2a42dddb1a5f8899c370ce5e68804e/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32326664613461652d346464352d343839642d616231302d3965626664616432326165302e6a7067)

## ParNew 收集器

*ParNew* 收集器是 *Serial* 收集器的多线程版本。

它是服务端场景下默认的新生代收集器，除了 Serial 收集器外，只有它能与 *CMS* 收集器配合使用，但目前它也只能和 *CMS* 收集器配合使用。

![img](https://camo.githubusercontent.com/810601a45fd3edebcabe7bd13cca344466e1caa0ec36544f174086f43044555c/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38313533386364352d316263662d346533312d383665352d6531393864663165303133622e6a7067)



## Parallel Scavenge 收集器

和 *ParNew* 一样，*Parallel Scavenge* 是多线程、新生代收集器。

缩短停顿时间是以牺牲吞吐量和新生代空间来换取的，新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而 *Parallel Scavenge* 的目标是达到一个可控制的吞吐量。

- 线程停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，适合Server场景。

- 高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合不需要太多交互的计算密集型任务。

<img src="http://store.secretcamp.cn/uPic/image-20210704180151526202107041801511625392911LWV8n2LWV8n2.png" alt="image-20210704180151526" style="zoom:33%;" />



## Serial Old 收集器

*Serial Old* 收集器是 *Serial* 收集器的老年代版本，基于标记 - 整理算法，也是给客户端场景下的虚拟机使用。

如果用在服务器场景下，它有两大用途：

- 在 *Parallel Old* 诞生以前与 *Parallel Scavenge* 收集器搭配使用。
- 作为 *CMS* 收集器的后备预案，在并发收集发生 *Concurrent Mode Failure* 时使用

![img](https://camo.githubusercontent.com/619f88e2830cee0ebd2cc5ca6a3ecd63e7b9ab419a91537e5ed8868ef0fd34c9/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30386633326664332d663733362d346136372d383163612d3239356232613739373266322e6a7067)



## Parallel Old 收集器

是 *Parallel Scavenge* 收集器的老年代版本，基于标记 - 整理算法。

在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 *Parallel Scavenge* + *Parallel Old* 的组合

![img](https://camo.githubusercontent.com/224de5079435a84b00846daf60b5c0e07283cea0cd03873c511f874246d2f17d/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32373866653433312d616638382d346139352d613839352d3963336238303131376465332e6a7067)



## CMS 收集器

*CMS*（Concurrent Mark Sweep）以获取最短回收停顿时间（Stop The World）为目标，其中 "Concurrent" 是指垃圾收集的线程和用户执行的线程是可以同时执行的，Mark Sweep 指的是 "标记 - 清除" 算法。

“标记” 是指将存活的对象和要回收的对象都给标记出来，“清除” 是指清除掉将要回收的对象。

分为以下四个流程：

- 初始标记（需要停顿）：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快。
- 并发标记（不需要停顿）：进行 GC Roots Tracing 的过程，也就是从GC Roots开始找到它能引用的所有其它对象的过程，它在整个回收过程中耗时最长，不需要停顿。
- 重新标记（需要停顿）：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。
- 并发清除（不需要停顿）：清除被标记了需要清除的对象，耗时较长，不需要停顿

在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。

缺点：

- 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。虽然不会导致用户线程停顿，但是占用了 CPU 资源用于 GC 导致致应用程序变慢，降低总吞吐量。

- 无法处理浮动垃圾，可能出现 *Concurrent Mode Failure* 

  浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。

  由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 *CMS* 收集器不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 *Concurrent Mode Failure*，这时虚拟机将临时启用 *Serial Old* 来替代 *CMS* ，所有应用线程被暂停，停顿时间变长。

- 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC 。

![img](https://camo.githubusercontent.com/06b53c4f9160093c891076bd6e65b31fccdbbe03fa7b23e754c7ba6e7835abda/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36326537373939372d363935372d346236382d386431322d6266643630396262326336382e6a7067)



## G1 收集器

*G1*（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多核 CPU 和大内存的场景下有很好的性能，HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。

java 堆被分为新生代和老年代，其它收集器进行收集的范围都是新生代或者老年代，而 *G1* 面向全堆，可以直接对新生代和老年代一起回收。

通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。

<img src="https://camo.githubusercontent.com/ac21bcb938d3b10ec2be009a0d2aa6317163cf3af46106771f1bf5ca058ca544/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39626264646565622d653933392d343166302d386538652d3262316130616137653061372e706e67" alt="img" style="zoom:67%;" />

每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region，通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。

![img](https://camo.githubusercontent.com/0f51e01c02ef3917df9a072b579a5004ae6f429dce742c32ba56d5c0de4da356/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66393965653737312d633536662d343766622d393134382d6330303336363935623566652e6a7067)



## 垃圾收集器的选择





# 内存分配与回收策略⛩

## 对象优先在Eden分配

大多数情况下，对象在新生代 `Eden` 区分配，当 `Eden` 区没有足够的空间进行分配时，会发起一次 `Minor GC` 。



## 大对象直接进入老年代

大对象指的是需要大量连续内存空间的java对象，典型的大对象是很长的字符串以及数组。

虚拟机有一个 `-XX:PretenureSizeThreshold` 参数，大于这个设置值的对象会直接在老年代分配，这样做的目的是避免在 `Eden` 区以及两个 `Survivor` 区之间发生大量的内存复制。



## 长期存活的对象将进入老年代

虚拟机给每个对象定义了一个对象年龄（age）计数器，如果对象在 `Eden` 出生并经过第一次 `Minor GC` 后仍然存活，并且能够被 `Survivor` 容纳的话，将被移动到 `Survivor` 空间中，并且对象的年龄加一。之后对象每在 `Survivor` 区中经过一次 `Minor GC` ，年龄就会加一，当年龄增加到一定程度（通常是15岁），就会晋升到老年代中。

虚拟机的 `-XX:MaxTenuringThreshold` 参数可以设置进入老年代的最大年龄。



## 动态对象年龄判定

为了更好的适应不同程序的内存情况，虚拟机不是永远要求对象的年龄达到 `MaxTenuringThreshold` 才可以进入老年代，如果在 `Survivor` 空间中相同年龄的所有对象大小的总和大于 `Survivor` 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。



## 空间分配担保

在发生 `Minor GC` 之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象占用的总空间，如果这个条件成立，那么 `Minor GC` 可以确保是安全的，此时虚拟机会检查 `HandPromotionFailure` 是否允许担保失败。

- 允许担保失败，则尝试进行一次 `Minor GC` ，尽管这是有风险的
- 不允许担保失败，直接进行一次 `Full GC`



担保失败：

新生代使用标记-复制算法，只使用一个 `Survivor` 空间来作为轮换备份，因为如果出现大量新生代对象在 `Minor GC` 后仍然存活，`Survivor` 空间不足就需要老年代进行担保，将 `Survivor` 空间中无法容纳的对象直接进入老年代。

当然，这么做的前提是老年代也有足够的空间，但 GC 之后有多少对象会存活是无法提前知晓的，所以会取每一次晋升到老年代的对象所需要空间的平均值作为经验判断，但是这并不能保证老年代的空间是足够的，所以可能会出现 “担保失败”。

如果发生了担保失败（HandlePromotionFailure），则会在失败后重新发起一次 `Full GC`



## Full GC 的触发条件

`Minor GC` 的触发条件非常简单，当 `Eden` 空间满时，就将触发一次 `Minor GC`，而 `Full GC` 则相对复杂，有以下条件：

### 调用System.gc()

只是建议虚拟机执行 `Full GC` ，但是虚拟机不一定真正去执行，不建议使用这种方式，而是让虚拟机管理内存。

### 老年代空间不足

老年代空间不足的常见场景有大对象直接进入老年代、长期存活的对象进入老年代等。

为了避免以上原因引起的 `Full GC`，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 `-Xmn` 参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 `-XX:MaxTenuringThreshold` 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。

### 空间分配担保失败

使用复制算法的 `Minor GC` 需要老年代的内存空间作担保，如果担保失败会执行一次 `Full GC`。





## 内存泄漏

内存泄漏本质上是长期存活对象引用短期存活对象，导致短期存活对象无法被垃圾回收。



# 虚拟机性能监控工具⛩

## jps

jps：虚拟机进程状况工具

```sh
jps
		-m：输出虚拟机进程启动时传递给主类 main() 函数的参数
		-l：输出主类的全名，如果进程执行的是JAR包，则输出JAR路径
		-v：输出虚拟机进程启动时的JVM参数
```



## jstat

jstat（JVM Statistics Monitoring Tool）是用于监视虚拟机各种运行状态信息的命令行工具。

它可以显示虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据。



## jinfo

jinfo（Configuration Info for Java）的作用是实时查看和调整虚拟机各项参数。



## jmap

jmap（Memory Map for Java）命令用于生成堆转储快照（一般称为heapdump或dump文件）。



## jhat

JDK提供 jhat（JVM Heap Analysis Tool）命令与 jmap 搭配使用，来分析 jmap 生成的堆转储快照。

 jhat内置了一个微型的HTTP/Web服务器，生成堆转储快照的分析结果后，可以在浏览器中查看。



## jstack

jstack（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照。

线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的目的通常是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间挂起等，都是导致线程长时间停顿的常见原因。

线程出现停顿时通过 jstack 来查看各个线程的调用堆栈， 可以获知没有响应的线程到底在后台做哪些事情，或者等待哪些资源。



# 类文件结构⛩

## Class文件

Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文 件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。

- 魔数

  每个 Class 文件的头 4 个字节被称为魔数，它的唯一作用是确定这个文件是否为 一个能被虚拟机接受的 Class 文件。

- 版本号

- 常量池

- 访问标志

- 类索引、父类索引与接口索引集合

- 字段表集合

- 方发表集合

- 属性表集合



## 字节码指令





# 类加载机制⛩

在字节码文件中描述的各种信息，最终都需要加载到虚拟机中才能够运行和使用，虚拟机将描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 java 类型，这就是虚拟机的类加载机制。



## 动态扩展

Java 中类型的加载、连接和初始化过程都是在程序运行期间完成的，这为 Java 应用提供了极高的扩展性和灵活性，Java 天生可以动态扩展的语言特性是依赖运行期动态加载和动态连接这个特点实现的。







## 类的生命周期

类从被加载进内存开始，到被卸载出内存为止，它的整个生命周期包括七个阶段：

- 加载（Loading）✔️
- 验证（Verification）✔️
- 准备（Preparation）✔️
- 解析（Resolution）✔️
- 初始化（Initialization）✔️
- 使用（Using）
- 卸载（Unloading）

其中验证、准备、解析三个阶段统称为连接（Linking）

<img src="http://store.secretcamp.cn/uPic/image-20210708225344529202107082253441625756024P2S0EWP2S0EW.png" alt="image-20210708225344529" style="zoom:50%;" />





## 类加载的时机

### 主动引用

虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）：

- 遇到 `new` 、 `getstatic` 、 `putstatic` 、 `invokestatic` 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这4条指令的场景是：
  - 使用 new 关键字实例化对象的时候；
  - 读取或设置一个类的静态字段（被 final修饰、已在编译期把结果放入常量池的静态字段除外）的时候；
  - 调用一个类的静态方法的时候。
- 使用 `java.lang.reflect` 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。
- 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
  - 接口的初始化不要求其父类都已进行初始化
- 当虚拟机启动时，用户需要指定一个要执行的主类，即包含 `main()` 方法的那个类，虚拟机会先初始化这个主类；
- 当使用 JDK 1.7 的动态语言支持时，如果一个 `java.lang.invoke.MethodHandle` 实例最后的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；



### 被动引用

以上五种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：

- 通过子类引用父类的静态字段，不会导致子类初始化。

  ```java
  public class SuperClass {
      public static int value = 123;
  
      static {
          System.out.println("SuperClass init");
      }
  }
  
  public class SubClass extends SuperClass {
      static {
          System.out.println("SubClass init");
      }
  }
  
  public class NotInitialzation01 {
      public static void main(String[] args) {
          System.out.println(SubClass.value);
      }
  }
  ```

  

- 通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。

  ```java
  public class NotInitialzation {
      public static void main(String[] args) {
          SuperClass[] superClasses = new SuperClass[10];
      }
  }
  ```

  

- 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。

  ```java
  public class ConstClass {
      static {
          System.out.println("ConstClass init");
      }
      public static final String HELLOWORLD = "hello world";
  
  }
  
  public class NotInitialzation {
      public static void main(String[] args) {
          System.out.println(ConstClass.HELLOWORLD);
      }
  }
  ```



`NotInitialzation` 类对 `ConstClass` 中常量的引用，实际上转化成了对 `NotInitialzation` 自身常量池的引用





## 类加载的过程

### 加载

在加载阶段，虚拟机需要做以下操作：

1. 通过一个类的全限定类名，根据字节码文件获取定义此类的二进制字节流

2. 将这个字节流代表的静态存储结构转化为 方法区的运行时数据结构

3. 在堆中生成一个代表这个类的 `java.lang.Class` 对象，作为方法区中这个类的各种数据的访问入口



非数组类型的加载：开发人员可以定义自己的类加载器去控制字节流的获取方式，例如重写一个类加载器的 `findClass()` 或 `loadClass()` 方法，根据自己的想法来赋予应用程序获取运行代码的动态性。即可以使用系统提供的类加载器，也可以使用用户自定义的类加载器

对于数组类的加载：数组类本身不通过类加载器创建，而是由 java 虚拟机直接创建，但数组类的元素类型（数组去掉所有维度的类型），最终还是要靠类加载器创建。



简要的说，加载阶段完成后，java虚拟机外部的二进制字节流就按照虚拟机要求的格式，存储在方法区之中。然后在堆内存中实例化一个 `java.lang.Class` 对象，这个对象将作为程序访问方法区中的类型数据的外部接口。

> *jdk1.6* 之前 Class 对象在方法区中，从 *jdk1.7* 开始在堆内存中。







### 验证

由于编译器的存在，java语言本身无法做到一些危险行为，例如访问数组边界以外的数据、将一个对象转型为未实现的类型等，这些行为都无法通过编译。但是Class文件并不一定都是由java源码编译而来的，虚拟机接收的字节流有可能是不安全的，所以要对其进行 "验证" 。

主要包括以下几点：

- 文件格式验证
- 元数据验证
- 字节码验证
- 符号引用验证



### 准备

准备阶段是正式为「类变量」分配内存并设置类变量初始值的阶段，这些变量使用的内存都会在「方法区」内分配。

> *jdk 1.8* 之后，类变量随着 Class 对象一起存放在 Java 堆中，"类变量在方法区" 就完全是一种对逻辑概念的表述，实际上内存是在堆中分配的。

这里分配的变量仅指被 `static` 关键字修饰的变量，不包括实例变量，实例变量会在对象「实例化」时随着对象被一起分配到「堆」中。

假设存在 `public static int value = 123;`

经过准备阶段后，value 的值为 0 而不是 123，因为当前还没有执行任何 java 方法，给 value 赋值的 `putstatic` 指令是在程序被编译后，存放于类构造器 `<clinit>()` 方法中，因此给 value 赋值 123 的操作将会在初始化阶段执行。

但如果该变量被 `final` 修饰，即 `public static final int value = 123` 类字段的字段属性表就会生成 `ConstantValue` 属性，那么准备阶段虚拟机就会根据 `ConstantValue` 的设置将 value 赋值 123



### 解析

解析阶段是虚拟机将常量池中的「符号引用」替换为「直接引用」的过程。

对于一些类和类的字段、方法的引用等，在编译时不知道其具体的位置，所以会使用符号引用，在加载时再具体的解析为直接引用。

- 符号引用：符号引用以一组符号来描述所引用的目标。符号引用可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用和虚拟机的布局无关，引 用的目标并不一定是已经加载到虚拟机内存当中的内容。
- 直接引用：直接引用就是可以直接指向目标的指针，或者能定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在虚拟机 的内存中存在。

在编译的时候每个 java 类都会被编译成一个字节码文件，但此时虚拟机并不知道所引用类的地址，多以就用符号引用来代替，而解析阶段就是为了把这个符号引用转化成为真正的地址的阶段。







```java
String s1 = "abc"
String s2 = new String("abc")
String s3 = new String("abc").intern()
```

在类编译时，会产生4个符号引用 s1，s2，s3，s4 以及一个字面量 abc，在类加载的解析阶段会解析符号引用并把字面量放入字符串常量池中。

s1 是 java 栈中的变量，通过字面量创建字符串，首先在常量池中查找是否存在相同的字符串，若存在，则直接将栈中的引用指向该字面量，若不存在，则在常量池中生成一个字符串，再将栈中的引用指向该字符串。

s2 会先在java堆中创建一个对象，存储对字符串常量池中的 abc 的引用，然后在java 栈中的引用变量指向这个对象

s3 中的 `intern()` 方法直接返回对 abc 常量的引用

> 调用 intern() 方法时，首先会检查字符串常量池中是否已经存在该字面量，如果不存在，则将字面量加入常量池，并返回指向该常量的引用，如果存在，则直接返回引用。







### 初始化

类的初始化阶段是类加载阶段的最后一步，在初始化阶段，才开始真正的加载java程序的代码（或者说是字节码）

初始化阶段是执行类构造器 `<clinit>()` 方法的过程

`<clinit>()` 方法是由编译器自动收集类中所有「静态变量的赋值动作」和「静态代码块」中的语句合并而成的，编译器收集的顺序取决于源文件中出现的顺序。



## 类加载器

### 类加载器的概念

在加载阶段，会 "通过一个类的全限定类名来获取描述此类的二进制字节流" ，这个动作是放到 java 虚拟机外部去实现的，以便让程序自己去决定如何去获取所需要的类，实现这个动作的代码模块就叫做「类加载器」



### 类加载器的类型

每一个类加载器，都有一个独立的类名称空间。

比较两个类是否相等的一个必要条件是：这两个类必须是同一个类加载器加载的



从 java 虚拟机的角度，类加载器分为两种：

1. 启动类加载器（*Bootstrap ClassLoader*）：使用 C++ 实现，是虚拟机自身的一部分

2. 所有其他的类加载器：由 java 实现，独立于虚拟机外部，全部继承自 `java.lang.ClassLoader`



从 java 开发者的角度，类加载器可以分为三种：

1. 启动类加载器（*Bootstrap ClassLoader*）

   启动类加载器用于加载java自带的核心类库，主要有：

   - 存放在 `<JAVA_HOME>/jre/lib` 目录中的类库，如 `rt.jar`

   - `-Xbootclasspath` 参数所指定的路径中的类库

   启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。



2. 扩展类加载器（*Extension ClassLoader*）

     扩展类加载器是由 `sun.misc.Launcher$ExtClassLoader` 实现的，负责加载以下类库：

   - `<JAVA_HOME>/jre/lib/ext` 中的类库

   - `java.ext.dir` 系统变量所指定路径中的所有类库

   扩展类加载器是由 Java 代码实现的，开发者可以直接在程序中使用扩展类加载器来加载 Class 文件。

  

3. 应用程序类加载器（*Application ClassLoader*）

    这个类加载器是由 `sun.misc.Launcher$AppClassLoader` 实现的。由于这个类加载器是 ClassLoader 中的 `getSystemClassLoader()` 方法的返回值，因此一般称为「系统类加载器」。

    它负责加载用户类路径 ClassPath 上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。



## 双亲委派模型

应用程序是由三种类加载器互相配合从而实现类加载，除此之外还可以加入自己定义的类加载器。

下图展示了类加载器之间的层次关系，称为双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系来实现，而不是继承关系。

<img src="http://store.secretcamp.cn/uPic/image-20210113091307635202101130913071610500387InNZKKInNZKK.png" alt="image-20210113091307635" style="zoom: 33%;" />



### 工作流程

工作过程：一个类加载器会将类加载请求委派给父类加载器，父类加载器收到类加载请求后又会委派给自己的父类，最终所有请求都会委派到启动类加载器。如果父类加载器无法完成加载（该类的 Class 文件不在该类加载器的加载路径中），则会委派给子类类加载器，直到该类被成功加载。

如果最后一个子类加载器也找不到该类，则抛出一个 *ClassNotFound* 异常。



### 双亲委派的优点

双亲委派模型使得java类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一，防止污染源代码。

例如 `java.lang.String` 存放在 `rt.jar` 中，如果编写另外一个 `java.lang.String` 并放到 `ClassPath` 中，那么程序中就会出现多个不同的 `String` 类，产生混乱。

```java
package java.lang;

public class String {
    public static void main(String[] args) {
        System.out.println();
    }
}
```

运行后会抛出异常：

```
错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:
   public static void main(String[] args)
否则 JavaFX 应用程序类必须扩展javafx.application.Application
```



由于双亲委派模型的存在，在 `rt.jar` 中的 `String` 比在 `ClassPath` 中的 `String` 优先级更高，这是因为 `rt.jar` 中的 `String` 使用的是启动类加载器，而 `ClassPath` 中的 `String` 使用的是应用程序类加载器。`rt.jar` 中的 `String` 优先级更高，那么程序中所有的 `String` 都是由 *Bootstrap ClassLoader* 加载的。



### 打破双亲委派模型

双亲委派模型并不是一个具有强制性约束的模型，而是Java设计者推荐给开发者们的类加载器实现方式。

#### JDNI

一个典型的例子是 JNDI 服务，JNDI 现在是 Java 的标准服务， 它的代码由启动类加载器来完成加载，肯定属于 Java 中很基础的类型 了。但 JNDI 存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的 ClassPath 下的 JNDI 服务提供者接口的代码，但是启动类加载器是无法加载这些代码的。

Java 的设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（*Thread Context ClassLoader*），这个类加载器可以通过`java.lang.Thread` 类的 `setContextClassLoader()` 方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。

JNDI 服务使用「线程上下文类加载器」去加载所需的 SPI（Service Provider Interface） 服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则。

当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在 *JDK 6*时，提供了 `java.util.ServiceLoader` 类，以 `META-INF/services` 中的配置信息，辅以责任链模式，算是给 SPI 的加载提供了一种相对合理的解决方案。



#### OSGi

用户越来越追求所谓程序的 "动态性"， 指的是代码热替换（Hot Swap）、模块热部署（Hot Deployment）等功能，实际上就是希望 Java 应用程序能像电脑外设那样，接上鼠标、u盘，不用重启机器就能立即使用。

OSGi 实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi 中称为 Bundle）都有一个自己的类加载器，当需要更换一个 Bundle 时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换。在 OSGi 环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。



## 模块化系统

*JDK 9* 中引入了 Java 模块化系统（Java Platform Module System，JPMS）。

为了能够实现模块化的关键目标 — 可配置的封装隔离机制，Java 虚拟机对类加载架构也做出了相应的变动调整，才使模块化系统得以顺利地运作。





# JVM性能调优⛩

https://blog.csdn.net/weixin_42447959/article/details/81637909









