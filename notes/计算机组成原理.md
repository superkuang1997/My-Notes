# 总线🍄

总线（Bus）是计算机各种功能部件之间传送信息的公共通信干线，它是由导线组成的传输线束

总线（Bus）是一组能为多个部件分时共享的公共信息传送线路。

分时和共享是总线的两个特点：

- 分时：指同一时刻只允许有一个部件向总线发送信息，若系统中有多个部件，则它们只能分时地向总线发送信息。

- 共享：指总线上可以挂接多个部件，各个部件之间互相交换的信息都可通过这组线路分时共享。在某一时刻只允许有一个部件向总线发送信息，但多个部件可同时从总线上接收相同的信息。



## 总线的分类

1. 片内总线：指芯片内部的总线，它是 CPU 芯片内部寄存器与寄存器之间、寄存器与 ALU 之间的公共连接线。

2. 系统总线：指计算机系统内各功能部件（CPU、主存、IO 接口）之间相互连接的总线。

3. 通信总线：指在计算机系统之间或计算机系统与其他系统（如远程通信设备、测试设备）之间传送信息的总线，通信总线也称外部总线。

此外，按时序控制方式可将总线划分为同步总线和异步总线，还可按数据传输格式将总线划分为并行总线和串行总线。



## 总线的结构

总线结构通常分为单总线结构、双总线结构和三总线结构等。

### 单总线结构

<img src="http://store.secretcamp.cn/uPic/image-20210805201427957202108052014281628165668Kmrn8lKmrn8l.png" alt="image-20210805201427957" style="zoom:50%;" />

### 双总线结构

<img src="http://store.secretcamp.cn/uPic/image-20210805201459556202108052014591628165699FxQaC1FxQaC1.png" alt="image-20210805201459556" style="zoom:50%;" />



### 三总线结构

<img src="http://store.secretcamp.cn/uPic/image-20210805201512941202108052015131628165713sS1z1KsS1z1K.png" alt="image-20210805201512941" style="zoom:50%;" />



## 总线的分类

1. 片内总线：芯片内部的总线
2. 系统总线：计算机各部件之间的信息传输线
   - 数据总线：双向，与机器字长、存储字长相关
   - 地址总线：单向：与存储地址、I/O 地址相关
   - 控制总线：有出有入，与中断请求、总线请求相关
3. 通信总线：计算机系统之间、计算机与其他系统之间通信
   - 串行通信
   - 并行通信



## 总线操作

### 同步定时方式

系统采用一个统一的时钟信号来协调发送和接收双方的传送定时关系。时钟产生相等的时间间隔，每个间隔构成一个总线周期。在一个总线周期中，发送方和接收方可以进行一次数据传送。因为采用统一的时钟，每个部件或设备发送或接收信息都在固定的总线传送周期中，一个总线的传送周期结束，下一个总线的传送周期开始。

优点：传送速度快，具有较高的传输速率；总线控制逻辑简单。

缺点：主从设备属于强制性同步，不能及时进行数据通信的有效性检验，可靠性较差。



### 异步定时方式

没有统一的时钟，也没有固定的时间间隔，完全依靠传送双方相互制约的 “握手” 信号来实现定时控制。

通常，把交换信息的两个部件或设备分为主设备和从设备，主设备提出交换信息的 “请求” 信号，经接口传送到从设备，从设备接到主设备的请求后，通过接口向主设备发出 “回答” 信号。

优点：总线周期长度可变，能保证两个工作速度相差很大的部件或设备之间可靠地进行信息交换，自动适应时间的配合。

缺点：比同步控制方式稍复杂一些，速度比同步定时方式慢。



## 总线嗅探

总线嗅探可以理解为 CPU 监听总线上的所有修改操作。

为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2 或其他）后再进行操作，但操作完不知道何时会回写到内存。

如果对声明了 *volatile* 的变量进行写操作，*JVM* 就会想处理器发送一条 Lock 前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。

根据 MESI 协议，每个处理器通过嗅探在总线上传播的数据来检查自己的缓存值是不是过期了，如果处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据库读到处理器缓存中。





# 存储器🍄



## 存储器的类型

按照层次分类：

1) 主存储器：简称主存，又称内存，用来存放计算机运行期间所需的大量程序和数据，CPU 可以直接随机地对其进行访问，也可以和高速缓存储器（Cache）及辅助存储器交换数据。其特点是容量较小、存取速度较快、价格成本高。

2) 辅助存储器：简称辅存，又称外存，是主存储器的后援存储器，用来存放当前暂时不用的程序和数据，以及一些需要永久性保存的信息，它不能与 CPU 直接交换信息。其特点是容量极大、存取速度较慢、价格成本低。

3) 高速缓冲存储器：简称 Cache，位于主存和 CPU 之间，用来存放正在执行的程序段和数据，以便 CPU 能高速地使用它们。Cache 的存取速度可与 CPU 的速度相匹配，但存储容量小、价格高。



按照存取方式分类：

1. 随机存储器（RAM）：存储器的任何一个存储单元的内容都可以随机存取，而且存取时间与存储单元的物理位置无关。优点是读写方便、使用灵活，主要用作主存或高速缓冲存储器。
2. 只读存储器（ROM）：存储器的内容只能随机读出而不能写入。信息一旦写入存储器就固定不变，即使断电，内容也不会丢失。因此，通常用它存放固定不变的程序、常数和汉字字库等。它与随机存储器可共同作为主存的一部分，统一构成主存的地址域。
3. 串行访问存储器：对存储单元进行读/写操作时,需按其物理位置的先后顺序寻址，包括顺序存取存储器（如磁带）与直接存取存储器（磁盘、光盘）。



## 多级存储结构

为了解决存储系统大容量、高速度和低成本 3 个相互制约的矛盾，在计算机系统中，通常采用多级存储器结构。

<img src="http://store.secretcamp.cn/uPic/image-20210805231817124202108052318171628176697usv45husv45h.png" alt="image-20210805231817124" style="zoom:50%;" />







## 高速缓存

高速缓冲技术就是利用程序访问的局部性原理，把程序中正在使用的部分存放在一个高速的、容量较小的 Cache 中，使 CPU 的访存操作大多数针对 Cache 进行，从而大大提高程序的执行速度。



### 基本工作原理

Cache 和主存都被划分为相等的块，Cache 块又称  Cache 行，每块由若干字节组成，块的长度称为块长（Cache 行长）。由于 Cache 的容量远小于主存的容量，所以 Cache 中的块数要远少于主存中的块数，因此 Cache 按照某种策略，预测 CPU 在未来一段时间内欲访存的数据，将其装入 Cache。

当 CPU 发出读请求时，若访存地址在 Cache 中命中，就将此地址转换成 Cache 地址，直接对 Cache 进行读操作，与主存无关。若 Cache 不命中，则仍需访问主存，并把此字所在的块一次性地从主存调入 Cache。若此时 Cache 已满，则需根据缓存淘汰算法替换 Cache 中原来的某块信息。

> CPU 与 Cache 之间的数据交换以字为单位，而 Cache 与主存之间的数据交换则以 Cache 块为单位





### 缓存一致性问题

高速缓存的引入也产生了一个新的问题：缓存一致性（Cache Coherence）。

在多路处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（Main Memory）。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致，同步回到主内存时就不知以哪个处理器的缓存数据为准。

例如执行 $i = i+1$ ，两个线程都从主存中复制一份 $i = 0$ 到高速缓存，然后 CPU 执行指令对 $i$ 进行加一操作，然后将数据写入高速缓存，最后将高速缓存中 i 最新的值刷新到主存当中。如果没有解决缓存一致性，那么回写到主存的时候，值会相互覆盖，还是 1 ，而不是 2 。

缓存一致性问题通常由两种解决方案：

1. 总线加锁
2. 缓存一致性协议



#### 总线加锁

所谓总线锁就是使用处理器提供的一个 `LOCK#` 信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞，那么该处理器可以独占主存。

在早期的 CPU 当中，是通过在总线上加 `LOCK#` 锁的形式来解决缓存不一致的问题。因为 CPU 和其他部件进行通信都是通过总线来进行的，如果对总线加 `LOCK#` 锁，也就阻塞了其他 CPU 对其他部件访问（如内存），从而使得只能有一个 CPU 能使用主存。



#### MESI协议

MESI（Modified-Exclusive-Shared-Invalid）协议是一种广为使用的缓存一致性协议。MESI 协议对内存数据访问的控制类似于读写锁，它使得针对同一地址的读内存操作是并发的，而针对同一地址的写内存操作是独占的。

<img src="http://store.secretcamp.cn/uPic/image-20210715220920383202107152209201626358160sK7YRlsK7YRl.png" alt="image-20210715220920383" style="zoom:40%;" />



MESI 指缓存行（Cache Line）的 4 种状态：

每个 Cache 的 Cache 控制器不仅知道自己的读写操作，而且也监听其它 Cache 的读写操作。每个 Cache line 所处的状态根据本核和其它核的读写操作在 4 个状态间进行转移。

- M：代表该 CL 中的内容被修改了，并且该 CL 只被缓存在该 CPU 的 cache 中。这个状态的 CL 的数据和主存中的不一样，在未来的某个时刻它会被写入到主存中（当其他 CPU 要读取该缓存行的内容时）。

  - 监听：必须监听其他缓存是否试图读该 CL 对应主存，其他缓存只有在该 CL 回写到主存后状态置为 E 后，才能操作主存中的对应数据

  - 状态转换：当被写回主存之后，该 CL 的状态会变成 E 状态。

- E：代表该 CL 对应的主存内容只被该 CPU 缓存，其他 CPU 没有缓存该 CL 对应主存中的内容。

  - 监听：必须监听其他缓存读主存中该 CL 对应内存的操作
  - 状态转换：一旦其他 CPU 读取该 CL 对应主存内容，转为 S 状态。本 CPU 如果回写了该 CL，则转为 M 状态

- S：数据不止存在本地 CPU 缓存中，还存在别的 CPU 的缓存中，这个状态的数据和内存中的数据是一致的。

  - 监听：必须监听其他 CL 使该 CL 无效的请求。
  - 状态转换：当有一个 CPU 修改该 CL 对应的主存内容时会使该缓存行变成 I 状态。

- I：代表该缓存行中的内容是无效的。

  - 监听：无
  - 状态转换：无



| 当前状态     | 事件                                                         | 行为                                                         | 下一个状态 |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------- |
| I(Invalid)   | Local Read                                                   | 如果其它Cache没有这份数据，本Cache从内存中取数据，Cache line状态变成E；如果其它Cache有这份数据，且状态为M，则将数据更新到内存，本Cache再从内存中取数据，2个Cache 的Cache line状态都变成S；如果其它Cache有这份数据，且状态为S或者E，本Cache从内存中取数据，这些Cache 的Cache line状态都变成S | E/S        |
| Local Write  | 从内存中取数据，在Cache中修改，状态变成M；如果其它Cache有这份数据，且状态为M，则要先将数据更新到内存；如果其它Cache有这份数据，则其它Cache的Cache line状态变成I | M                                                            |            |
| Remote Read  | 既然是Invalid，别的核的操作与它无关                          | I                                                            |            |
| Remote Write | 既然是Invalid，别的核的操作与它无关                          | I                                                            |            |
| E(Exclusive) | Local Read                                                   | 从Cache中取数据，状态不变                                    | E          |
| Local Write  | 修改Cache中的数据，状态变成M                                 | M                                                            |            |
| Remote Read  | 数据和其它核共用，状态变成了S                                | S                                                            |            |
| Remote Write | 数据被修改，本Cache line不能再使用，状态变成I                | I                                                            |            |
| S(Shared)    | Local Read                                                   | 从Cache中取数据，状态不变                                    | S          |
| Local Write  | 修改Cache中的数据，状态变成M，其它核共享的Cache line状态变成I | M                                                            |            |
| Remote Read  | 状态不变                                                     | S                                                            |            |
| Remote Write | 数据被修改，本Cache line不能再使用，状态变成I                | I                                                            |            |
| M(Modified)  | Local Read                                                   | 从Cache中取数据，状态不变                                    | M          |
| Local Write  | 修改Cache中的数据，状态不变                                  | M                                                            |            |
| Remote Read  | 这行数据被写到内存中，使其它核能使用到最新的数据，状态变成S  | S                                                            |            |
| Remote Write | 这行数据被写到内存中，使其它核能使用到最新的数据，由于其它核会修改这行数据，状态变成I | I                                                            |            |





# I/O🍄

输入/输出 是以主机为中心而言的，将信息从外部设备传送到主机称为输入，反之称为输出。输入/输出 系统解决的主要问题是对各种形式的信息进行输入和输出的控制。



## I/O控制方式

1) 程序查询方式：由 CPU 通过程序不断査询 IO 设备是否已做好准备，从而控制 IO 设备与主机交换信息。

2) 程序中断方式：只在 I/O 设备准备就绪并向 CPU 发出中断请求时才予以响应。
3)  DMA 方式：主存和 I/O 设备之间有一条直接数据通路，当主存和 I/O 设备交换信息时，无须调用中断服务程序。



### 程序查询方式

信息交换的控制完全由主机执行程序实现，主机进行 I/O 操作时，先发出询问信号，读取设备的状态并根据设备状态决定下一步操作究竟是进行数据传送还是等待。

优点：设计简单

缺点：CPU 不断轮询 I/O设备状态，直到外设准备就绪。CPU 与 I/O 串行操作，一段时间只能与一台外设交换信息，效率很低。



### 程序中断方式

CPU 在程序中安排好于某个时刻启动某台外设，然后 CPU 继续执行原来的程序，不需要像查询方式那样一直等待外设准备就绪。

一旦外设完成数据传送的准备工作，就主动向 CPU 发出中断请求，请求 CPU 为自己服务。在可以响应中断的条件下，CPU 暂时中止正在执行的程序，转去执行中断服务程序为外设服务，在中断服务程序中完成一次主机与外设之间的数据传送，传送完成后，CPU 返回原来的程序。

<img src="http://store.secretcamp.cn/uPic/image-20210805195418587202108051954181628164458KlNrs2KlNrs2.png" alt="image-20210805195418587" style="zoom: 50%;" />



### DMA方式

DMA 方式是一种完全由硬件进行成组信息传送的控制方式，它具有程序中断方式的优点，即在数据准备阶段，CPU 与外设并行工作。DMA 方式在外设与内存之间开辟一条 “直接数据通道”，信息传送不再经过 CPU，降低了 CPU 在传送数据时的开销。

主存和 DMA 接口之间有一条直接数据通路，由于数据传送不经过 CPU，也就不需要保护、恢复 CPU 现场等烦琐操作，但是通过 DMA 方式传输完数据后要通过中断方式进行后处理。

流程：

1) 接受外设发出的 DMA 请求，并向 CPU 发出总线请求。
2) CPU 响应此总线请求，发出总线响应信号，接管总线控制权，进入 DMA 操作周期。
3) 确定传送数据的主存单元地址及长度，并自动修改主存地址计数和传送长度计数。
4) 规定数据在主存和外设间的传送方向，发出读写等控制信号，执行数据传送操作 
5) 向 CPU 报告 DMA 操作的结東。





# CPU🍄

## CPU缓存的概念

CPU的处理能力要远比内存强，主内存执行一次内存读、写操作的时间可能足够处理器执行上百条的指令。为了弥补处理器与内存处理能力之间的鸿沟，在内存和处理器之间引入了高速缓存（Cache）。

CPU 的高速缓存是一种存取速率远比主内存快而容量远比主内存小的存储部件，每个处理器都有其高速缓存。CPU 缓存一般直接跟 CPU 芯片集成或位于主板总线互连的独立芯片上。

为了简化与内存之间的通信，高速缓存控制器是针对数据块，而不是字节进行操作的。高速缓存其实就是一组称之为缓存行（Cache Line）的固定大小的数据块组成的，典型的一行是 64 字节。

<img src="http://store.secretcamp.cn/uPic/image-20210425215640354202104252156401619359000Jv3tKdJv3tKd.png" alt="image-20210425215640354" style="zoom: 33%;" />

CPU 的读（load）实质上就是从缓存中读取数据到寄存器（register）里，在多级缓存的架构中，如果缓存中找不到数据（cache miss），就会层层读取二级缓存三级缓存，一旦所有的缓存里都找不到对应的数据，就要去内存里寻址了。寻址到的数据首先放到寄存器里，其副本会驻留到CPU的缓存中。

CPU 的写（store）也是针对缓存作写入。并不会直接和内存打交道，而是通过某种机制实现数据从缓存到内存的写回（write back）。



## CPU缓存的意义

CPU 往往需要重复处理相同的数据、重复执行相同的指令，如果这部分数据、指令 CPU 能在缓存中找到，那么就不需要从内存或硬盘中再读取数据、指令，从而减少了整机的响应时间。

缓存的意义满足以下两种局部性原理：

- 时间局部性（Temporal Locality）：如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。
- 空间局部性（Spatial Locality）：如果一个存储器的位置被引用，那么将来他附近的位置也会被引用。







# 磁盘🍄

## 磁盘的结构

磁盘主要由五个部分组成：

1. 盘片（platter）
2. 磁头（head）
3. 磁道（track）
4. 扇区（sector）
5. 柱面（cylinder）



- 盘片和磁头

  硬盘中一般会有多个盘片组成，每个盘片包含两个面，每个盘面都对应地有一个读/写磁头。受到硬盘整体体积和生产成本的限制，盘片数量都受到限制，一般都在5片以内。盘片的编号自下向上从0开始，如最下边的盘片有0面和1面，再上一个盘片就编号为2面和3面。

  <img src="http://store.secretcamp.cn/uPic/image-202106022205434922021060222054416226427445O2vTb5O2vTb.png" alt="image-20210602220543492" style="zoom: 33%;" />



- 扇区和磁道

  下图显示的是一个盘面，盘面中一圈圈灰色同心圆为一条条磁道，从圆心向外画直线，可以将磁道划分为若干个弧段，每个磁道上一个弧段被称之为一个扇区（绿色部分）。扇区是磁盘的最小组成单元，通常是 512 字节。

  由于不断提高磁盘的大小，部分厂商设定每个扇区的大小是 4096 字节

  <img src="http://store.secretcamp.cn/uPic/image-20210602220637000202106022206371622642797EkCOi1EkCOi1.png" alt="image-20210602220637000" style="zoom:40%;" />



- 磁头和柱面

  硬盘通常由重叠的一组盘片构成，每个盘面都被划分为数目相等的磁道，并从外缘的 "0" 开始编号，具有相同编号的磁道形成一个圆柱，称之为磁盘的柱面。磁盘的柱面数与一个盘面上的磁道数是相等的。由于每个盘面都有自己的磁头，因此，盘面数等于总的磁头数。 

  <img src="http://store.secretcamp.cn/uPic/image-20210602220741603202106022207411622642861e9IYlue9IYlu.png" alt="image-20210602220741603" style="zoom:33%;" />









## 磁盘的读取特性

### 顺序I/O

本次 I/O 给出的初始扇区地址和上一次 I/O 的结束扇区地址是完全连续或者相隔不多的。

反之，如果相差很大，则算作一次随机 I/O。

<img src="http://store.secretcamp.cn/uPic/image-20210602221112492202106022211121622643072D9NlGdD9NlGd.png" alt="image-20210602221112492" style="zoom:50%;" />



顺序 I/O 效率远高于随机 I/O，在做连续 I/O 的时候，磁头几乎不用换道，或者换道的时间很短；



### 随机I/O

随机I/O 需要 磁头不停地换道，造成效率的极大降低。

<img src="http://store.secretcamp.cn/uPic/image-20210602221126454202106022211261622643086nV3HYlnV3HYl.png" alt="image-20210602221126454" style="zoom:50%;" />



