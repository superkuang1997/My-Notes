# HTTP🎃 

HTTP 属于 OSI 网络七层协议模型中的应用层，由请求和响应构成，是一个标准的客户端服务器模型。

HTTP是一个无状态的协议，默认端口号为80。

无状态是指一种把每个请求作为与之前任何请求都无关的独立的事务的



## URL

客户端（Client）：发送请求获取服务器资源的一端

服务端（Server）：提供资源响应的一端

URI（Uniform Resource Identify ）：统一资源标识符

URL（Uniform Resource Locator）：统一资源定位符

URI用字符串标识某一互联网资源，而URL表示资源的地点（即在互联网上所处的位置）。URL是URI的子集。

```
protocol://host [:port]/path/[?query1&query2]#fragment
http://www.itcast.cn/index.html?name=andy&age=18#link
```

| 组成     | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| protocol | 通信协议常用的http，ftp，maito等                             |
| host     | 主机（域名）www.itheima.com                                  |
| port     | 端口号可选，省略时使用方案的默认端口如http的默认端口为80     |
| path     | 路径由零或多个`/`符号隔开的字符串，一般用来表示主机上的一个目录或文件地址 |
| query    | 参数以键值对的形式，通过`&`符号分隔开来                      |
| fragment | 片段 #后面内容常见于链接锚点                                 |



## HTTP版本

目前主流的 HTTP/1.1 自 1999 年发布后没有再经过修订，已经逐渐无法适应当下的 Web 环境

### Ajax

Ajax（Asynchronous JavaScript and XML，异步 JavaScript 与 XML 技术）是一种有效利用 JavaScript 和DOM（Document Object Model，文档对象模型）的操作，以达到局部 Web 页面替换加载的异步通信手段。和以前的同步通信相比，由于它只更新一部分页面，响应中传输的数据量会因此而减少，这一优点显而易见。

然而，利用 Ajax 实时从服务器获取内容，有可能会导致大量请求产生，因此，Ajax 仍未解决 HTTP 协议本身存在的问题。



### SPDY

1. 降低延迟

   针对HTTP高延迟的问题，SPDY优雅的采取了多路复用（multiplexing）。多路复用通过多个请求stream共享一个tcp连接的方式，解决了HOL blocking的问题，降低了延迟同时提高了带宽的利用率。

2. 请求优先级

   多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。

3. header压缩

   前面提到HTTP1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。

4. 基于HTTPS的加密协议传输

   大大提高了传输数据的可靠性。

5. 服务端推送（server push）

   采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。



### WebSocket

WebSocket是Web浏览器与Web服务器之间全双工通信标准。



### HTTP/2.0 

HTTP/2.0 建立在 SPDY 和 WebSocket 基础之上，目标是改善用户在使用 Web 时的速度体验。

HTTP2.0 和 HTTP1.X 相比的新特性：

- 新的二进制格式（Binary Format）

  HTTP1.X 的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。

- 多路复用（MultiPlexing）

  即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的id将request再归属到各自不同的服务端请求里面。

- header压缩

  如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。

- 服务端推送（server push）

  同SPDY一样，HTTP2.0也具有server push功能。



## HTTP方法

### GET

GET方法用来请求已被URI识别的资源。指定的资源经服务器端解析后返回响应内容。

如果请求的资源是文本，那就保持原样返回；如果是像CGI（Common Gateway Interface，通用网关接口）那样的程序，则返回经过执行后的输出结果。

### POST

POST方法用来传输实体的主体。

虽然用GET方法也可以传输实体的主体，但一般不用GET方法进行传输，而是用POST方法。虽说POST的功能与GET很相似，但POST的主要目的并不是获取响应的主体内容。

### PUT

PUT方法用来传输文件。就像FTP协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求URI指定的位置。

### HEAD

HEAD方法和GET方法一样，只是不返回报文主体部分。用于确认URI的有效性及资源更新的日期时间等。

### DELETE

DELETE方法用来删除文件，是与PUT相反的方法。DELETE方法按请求URI删除指定的资源。

### OPTIONS

OPTIONS方法用来查询针对请求URI指定的资源支持的方法。





# HTTP报文🎃 

## HTTP报文结构

用于 HTTP 协议交互的信息被称为 HTTP 报文。客户端的 HTTP 报文叫做请求报文，服务器端的叫做响应报文。HTTP 报文本身是由多行数据构成的字符串文本。

报文结构：` 报文首部 + 空行(CR+LF) + 报文主体`

<img src="http://store.secretcamp.cn/uPic/HTTP01202103012046201614602780Q0KhByQ0KhBy.png" style="zoom:67%;" />



请求行：包含用于请求的方法，请求 URI 和 HTTP 版本

```
GET /index.html HTTP/1.1
```

状态行：包含表明响应结果的状态码，原因短语和HTTP版本

```
HTTP/1.1 200 OK
```

![](http://store.secretcamp.cn/uPic/HTTP02202103012109131614604153etWpLCetWpLC.png)











## HTTP首部

HTTP报文分为请求报文和响应报文

| HTTP请求报文首部              | HTTP响应报文首部           |
| ----------------------------- | -------------------------- |
| 请求行（方法，URL，HTTP版本） | 状态行（HTTP版本，状态码） |
| 请求首部字段                  | 响应首部字段               |
| 通用首部字段                  | 通用首部字段               |
| 实体首部字段                  | 实体首部字段               |



### 通用首部字段

| 协议头        | 说明                                      | 举例                                                         |
| ------------- | ----------------------------------------- | ------------------------------------------------------------ |
| Connection    | 客户端（浏览器）想要优先使用的连接类型    | Connection: keep-alive (Upgrade)                             |
| Date          | 报文创建时间                              | Date: Dec, 26 Dec 2015 17: 30: 00 GMT                        |
| Cache-Control | 用来指定当前的请求/回复中是否使用缓存机制 | Cache-Control: no-store                                      |
| Via           | 告诉服务器，这个请求是由哪些代理发出的    | Via: 1.0 fred, 1.1 [itbilu.com.com](http://itbilu.com.com/) (Apache/1.1) |



### 请求首部字段

| 协议头          | 说明                                     | 举例                                               |
| --------------- | ---------------------------------------- | -------------------------------------------------- |
| Accept          | 告诉服务器自己允许哪些媒体类型           | Accept: text/plain                                 |
| Accept-Charset  | 浏览器申明可接受的字符集                 | Accept-Charset: utf-8                              |
| Accept-Encoding | 浏览器申明自己接收的编码方法             | Accept-Encoding: gzip, deflate                     |
| Authorization   | 用于表示HTTP协议中需要认证资源的认证信息 | Authorization: Basic OSdjJGRpbjpvcGVul ANIc2SdDE== |
| User-Agent      | 浏览器的身份标识字符串                   | User-Agent: Mozilla/……                             |
| Host            | 表示服务器的域名以及服务器所监听的端口号 | Host: www.itbilu.com:80                            |



### 响应首部字段

| 协议头      | 说明                       | 举例                                         |
| ----------- | -------------------------- | -------------------------------------------- |
| Age         | 创建响应的时间             | Age：5744337                                 |
| Server      | 告知客户端服务器信息       | Server: Apache/1.3.27 (Unix) (Red-Hat/Linux) |
| Retry-After | 告知客户端多久后再发送请求 | Retry-After: 120                             |
| Location    | 表示重定向后的 URL         | Location:https://www.baidu.com               |



### 实体首部字段

| 协议头           | 说明                                          | 举例                                   |
| ---------------- | --------------------------------------------- | -------------------------------------- |
| Allow            | 对某网络资源的有效的请求行为，不允许则返回405 | Allow: GET, HEAD                       |
| Content-encoding | 返回内容的编码方式                            | Content-Encoding: gzip                 |
| Content-Length   | 返回内容的字节长度                            | Content-Length: 348                    |
| Content-Type     | 返回内容的 MIME 类型                          | Content-Type: text/html; charset=utf-8 |
| Expires          | 响应过期的日期和时间                          | Expires: Thu, 01 Dec 2010 16:00:00 GMT |



### 其他首部字段

| 协议头          | 说明                                               | 举例                                    |
| --------------- | -------------------------------------------------- | --------------------------------------- |
| Set-Cookie      | 在用户状态管理中使用的cookie信息（响应首部）       |                                         |
| Cookie          | 服务器接收到的cookie信息（请求首部）               |                                         |
| X-Frame-Options | 用于控制网站内容在其他Web网站的Frame标签的显示问题 | X-Frame-Options: <br>DENY \| SAMEORIGIN |
| DNT             | 表示Do Not Trace                                   | DNT:1                                   |



## 状态码

### 1XX

信息，服务器收到请求，需要请求者继续执行操作

### 2XX

成功，操作被成功接收并处理

- 200：OK，请求成功

### 3XX

重定向，需要进一步的操作以完成请求

### 4XX

客户端错误，请求包含语法错误或无法完成请求

- 400：Bad Request，客户端请求的语法错误，服务器无法理解

- 403：Forbidden，服务器理解请求客户端的请求，但是拒绝执行此请求
- 404：Not Found，服务器无法根据客户端的请求找到资源
- 405：Method Not Allowed，客户端请求中的方法被禁止

### 5XX

服务器错误，服务器在处理请求的过程中发生了错误

- 500：Internal Server Error，服务器内部错误，无法完成请求





# HTTP相关问题🎃 

## 长连接与短连接

长连接：多用于操作频繁，点对点的通讯，而且客户端连接数目较少的情况。例如即时通讯、网络游戏等。

短连接：用户数目较多的Web网站的HTTP服务一般用短连接。例如京东，淘宝这样的大型网站一般客户端数量达到千万级甚至上亿，若采用长连接势必会使得服务端大量的资源被无效占用，所以一般使用的是短连接。



## Keep-Alive

在早期的 HTTP/1.0 中，浏览器每次发起HTTP请求都要与服务器创建一个新的TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。然而创建和关闭连接的过程需要消耗资源和时间，为了减少资源消耗，缩短响应时间，就需要重用连接。

在 HTTP/1.1 版本中默认使用持久连接，在 Keep-Alive 方式下，服务器在响应后保持该 TCP 连接打开，在同一个客户机与服务器之间的后续请求和响应报文可通过相同的连接进行传送。

<img src="http://store.secretcamp.cn/uPic/image-20210301211142613202103012111421614604302grDEoIgrDEoI.png" alt="image-20210301211142613" style="zoom: 50%;" />



Keep-Alive 并不是没有缺点的，当长时间的保持 TCP 连接时容易导致系统资源被无效占用，若对 Keep-Alive 模式配置不当，将有可能比非Keep-Alive 模式带来的损失更大。因此，需要正确地设置 timeout 参数，当TCP连接在传送完最后一个 HTTP 响应，该连接会保持 timeout 秒，之后就开始关闭这个链接。



## GET与POST的区别

- GET 提交的数据会放在 URL 之后，并且请求参数会被完整的保留在浏览器的记录里，由于参数直接暴露在 URL 中，可能会存在安全问题，因此往往用于获取资源信息。而 POST 参数放在请求主体中，并且参数不会被保留，相比 GET 方法，POST方法更安全，主要用于修改服务器上的资源。

- GET请求只支持 URL 编码，POST 请求支持多种编码格式。

- GET只支持 ASCII 字符格式的参数，而 POST 方法没有限制。

- GET提交的数据大小有限制（这里所说的限制是针对浏览器而言的），而 POST 方法提交的数据没限制

- GET方法产生一个 TCP 数据包，POST 方法可能产生两个。





## HTTP请求的全过程

发起请求之前：

1. DHCP 配置主机 IP
2. NAT 将私有 IP 转为公有 IP



发起请求：

2. DNS解析
   - 浏览器缓存 -> 系统缓存 -> 路由器缓存 -> 网络供应商缓存 -> 递归搜索DNS服务器
2. 客户端获取到服务端的 IP 地址后，发起 TCP 三次握手
   - 负载均衡
   - ARP 解析服务端的 MAC 地址
3. 建立 TCP 连接后发起 HTTP 请求
4. 服务器响应 HTTP 请求
   - 三层架构后台处理阶段
   - 业务逻辑处理完后，由表现层发出 HTTP 响应
5. 浏览器解析 HTML 代码，并请求 HTML 代码中的资源
   - CDN：如果请求的数据是静态文件且在 CDN 上，那么 CDN 服务器又会处理这个用户的请求
6. 浏览器对页面进行渲染呈现给用户
7. 断开 TCP 连接（长连接则不会立即断开）



# Cookie和Session🎃 

HTTP是一种无状态协议，即HTTP协议自身不对请求和响应之间的通信状态进行保存，使用HTTP协议时，每当有新的请求发送时，都会有对应的新响应产生，这是为了能够快速的处理大量事务。随着Web发展，许多网站都希望能够保持用户的状态，于是引入了会话技术。

会话（Session）跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。常用的会话跟踪技术是Cookie与Session。

- Cookie：通过在客户端记录信息确定用户身份

- Session：通过在服务器端记录信息确定用户身份

一个用户的所有请求操作都应该属于同一个会话，而另一个用户的所有请求操作则应该属于另一个会话，二者不能混淆。由于HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。



## Cookie

Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。

当服务器发送响应消息时，在HTTP响应头中设置 Set-Cookie 字段，用来存储客户端的状态信息。客户端解析出HTTP响应头中的字段信息，并根据其生命周期创建不同的Cookie，这样一来每次浏览器发送HTTP请求的时候都会带上Cookie字段，从而实现状态保持。

- 优点：服务器不用保存状态信息，减轻服务器存储压力，同时便于服务端做水平拓展。

- 缺点：该方式不够安全，因为状态信息存储在客户端，这意味着不能在会话中保存机密数据。除此之外，浏览器每次发起 HTTP 请求时都需要发送额外的 Cookie 到服务器端，会占用更多带宽。

> 拓展：Cookie被禁用了怎么办？
> 若遇到 Cookie 被禁用的情况，则可以通过重写URL的方式将会话标识放在URL的参数里，也可以实现会话保持。



## Session

Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。

在客户端第一次向服务器发送HTTP请求后，服务器会创建一个 Session 对象并将客户端的身份信息以键值对的形式存储下来，然后分配一个会话标识（ SessionId ）给客户端，这个会话标识一般保存在客户端Cookie中，之后每次该浏览器发送 HTTP请求都会带上Cookie中的 SessionId 到服务器，服务器根据会话标识就可以将之前的状态信息与会话联系起来，从而实现会话保持。

- 优点：安全性高，因为状态信息保存在服务器端。

- 缺点：由于大型网站往往采用的是分布式服务器，浏览器发送的HTTP请求一般要先通过负载均衡器才能到达具体的后台服务器，倘若同一个浏览器两次HTTP请求分别落在不同的服务器上时，基于Session的方法就不能实现会话保持了。



## 比较

基于Cookie的会话保持与基于Session实现的会话保持最主要的区别是前者完全将会话状态信息存储在浏览器Cookie中。





# HTTPS🎃

## HTTPS的概念

HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer）是以安全为目标的 HTTP 协议，在 HTTP 的基础上通过传输加密和身份认证的方式保证了传输过程的安全性。

HTTP 协议中没有加密机制，但可以通过和 SSL（Secure Socket Layer，安全套接层）或 TLS（Transport Layer Security，安全层传输协议）的组合使用，加密 HTTP 的通信内容，与 SSL 组合使用的 HTTP 被称为 HTTPS 。

HTTPS 是 HTTP 直接将报文信息传输给 SSL 套接字进行加密，SSL 加密后将加密后的报文发送给 TCP 套接字，然后 TCP 套接字再将加密后的报文发送给目的主机，目的主机将通过 TCP 套接字获取加密后的报文给SSL套接字，SSL解密后交给对应进程。



## HTTP的缺陷

传统的 HTTP 协议通信：直接将报文信息传输到 TCP，然后 TCP 再通过 TCP 套接字发送给目的主机上。

- 通信使用明文（不加密），内容可能会被窃听
- 不验证通信方的身份，任何人都可以发送请求，因此有可能遭遇伪装
- 无法证明报文的完整性，所以有可能已遭篡改



## 加密方式

RSA 是一种公钥密码体制，现在使用非常广泛，这个密码体制分为三部分：公钥、私钥、加密算法，其中公钥和加密算法是公开的，私钥是自己保密的。这种机制最大的特点是，通过公钥加密的密文只有对应的私钥才能解密，同样通过私钥加密的密文也只有对应的公钥才能解密。

公钥与私钥就是两组具有某种函数关系的数字串，可以相互之间加密解密。



### 对称加密

加密和解密同用一个密钥的方式称为对称加密（共享密钥加密）。客户端根据密钥对数据就行加密，服务端根据密钥对数据进行解密，所以加密和解密都需要密钥。

❗ 存在的问题：共享密钥加密的前提是将密钥成功发送给对方，然而在发送密钥的过程中通信可能会遭到监听，那么密钥就会遭到泄漏。



### 非对称加密

非对称加密（公开密钥加密）使用一对非对称的密钥。一把叫做私有密钥（private key），另一把叫做公开密钥（public key）。私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。

使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。

❗  存在的问题：无法证明公开密钥本身是货真价实的，因为在公开密钥的传输过程中，真正的公开密钥可能会被替换。



HTTPS 采用了混合加密方式，在密钥交换环节现在用非对称加密让客户端将密钥发送给服务端，之后采用对称加密进行通信。



## 数字证书

数字证书是 HTTPS 实现安全传输的基础，它是由权威的数字证书认证（CA）机构颁发的。

由于公开密钥加密自身存在的问题：即无法证明服务端的公开密钥是货真价实的。为了解决这个问题，数字证书认证机构（CA）颁发了公开密钥证书来证明服务器公开密钥的真实性。

1. 服务端相关人员向数 CA 发出申请
2. CA 验证申请者的身份，对申请的公开密钥做数字签名，并将公开密钥和公钥证书绑定
3. 服务端将 CA 颁布的公钥证书发送给客户端
4. 客户端使用证书中的公开密钥对向 CA 认证数字签名，验证成功则说明公钥真实



证书的主要内容有：

- 公钥

- 证书的发布机构

- 证书持有者

- 证书有效期

- 指纹及指纹算法

  指纹用来保证证书的完整性的，确保证书没有被篡改。证书在发布之前，CA 对证书的内容用指纹算法（sha1或sha256）计算得到一个 hash 值，这个 hash 值就是指纹。

- 签名

  签名是在信息后面加上的一段数字串，可以证明该信息有没有被篡改。数字证书发布的时，CA 将证书的指纹和指纹算法通过自己的私钥加密，得到的就是证书的签名。



### 根证书

CA 除了给别人颁发证书以外，它也有自己的证书，这个证书是机构自己颁发给自己的，它被称为根证书。根私钥是 CA 绝对保密的，在验证其他证书的过程中起着核心的作用。

世界上权威 CA 机构的根证书都是预先嵌入到浏览器中的，HTTPS 过程中如果在浏览器系中没有找到对应的根证书，就代表此机构不是受信任的，那么就会警告无法确认证书的真假。



### 证书的验证过程

1. 在 HTTPS 中，服务端接收到请求后，就会给浏览器发送一个自己的 CA 数字证书。

2. 如果找到了证书颁发机构的根证书，那么就从根证书中取得那个根公钥，用根公钥去解密此证书的数字签名，成功解密的话就得到证书的指纹 h1 和指纹算法。
3. 用指纹算法对当前接收到的证书内容再进行一次 hash 计算得到另一个值 h2，如果此时 h1 和 h2 是相等的，就代表证书没有被篡改过，验证通过。如果证书被篡改过，h1 和 h2 是不可能相等的，验证不通过。
   





## HTTPS的安全通信过程

1. 客户端在浏览器里输入一个 HTTPS 网址，然后连接到服务端的 443 端口，向服务端发送 Client Hello 报文，以明文传输请求信息，发送的信息主要包含版本信息，加密套件候选列表，压缩算法候选列表，随机数，扩展字段等信息。
2. 服务端返回协商的信息结果，包括选择使用的协议版本、选择的加密套件、选择的压缩算法、随机数以及数字证书。数字证书中包含证书的颁发机构、过期时间、服务端的公钥等信息。
3. 客户端验证证书的合法性，包括是否可信，是否吊销，过期时间等（通过根证书）。
4. 客户端确认证书的有效性后，生成一串随机数（即对称加密的密钥），用公钥对该随机数进行加密后发送给服务端。目的是为了让服务端得到这个随机值。
5. 客户端向服务端发送 Finish 报文，通知服务端之后的通信采用对称加密。
6. 服务器接收到加密的随机数后，用私钥对其进行解密后得到随机数，该随机数即对称加密的密钥。服务器向客户端发送报文，同意采用对称加密进行通信。
7. 服务器向客户端发送 Finish 报文
8. 客户端与服务端的 Finish 报文交换完成后，SSL 连接建立完成，开始进行 HTTP 通信。



<img src="http://store.secretcamp.cn/uPic/HTTPS_1202103012131491614605509kDsn0xkDsn0x.png" style="zoom:80%;" />











## HTTPS的缺点

HTTPS 比 HTTP 要慢 2~100 倍，因为 HTTPS 还需要做服务器、客户端双方加密及解密处理，因此会消耗 CPU 和内存等硬件资源。和 HTTP 通信相比，SSL 通信部分消耗网络资源，同时又因为要对通信进行处理，所以时间上又延长了，所以 SSL 的慢主要是指通信慢和大量消耗 CPU 及内存资源。

 

## HTTP和HTTPS比较

- HTTP 协议以明文方式发送内容，数据都是未加密的，安全性差；HTTPS 数据传输过程是加密的，安全性好。

- HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80 端口，后者是 443 端口。

- HTTPS 协议需要到数字认证机构（CA）申请证书，一般需要一定的费用。

- HTTP 页面响应比 HTTPS 快，主要因为 HTTP 使用 TCP 的 3 次握手建立连接，而 HTTPS 除了 TCP 的 3 次握手，还需要经历一个 SSL 协商过程。









